# See http://www.gnu.org/software/bison/manual/html_mono/bison.html#GLR-Parsers
%strict
%token ID INT NUM

%right '='
%left '+'

%tree bypass
%%
prog:
    %name EMPTY
    /* empty */
  | %name PROG
    prog stmt
;

stmt: 
    %name EXP
    expr ';' 
  | %name DECL
    decl    
;

expr:
    %name EXPID
    ID
  | %name NUM 
    NUM
  | %name TYPECAST
    INT '(' expr ')' /* typecast */ 
  | %name PLUS
    expr '+' expr
  | %name ASSIGN
    expr '=' expr
;

decl:
    %name DECLARATOR
    INT declarator ';'
  | %name DECLARATORINIT
    INT declarator '=' expr ';'
;

declarator:
    %name DECID
    ID
  | '(' declarator ')'
;

%%

sub _Error {
  my $parser = shift;

  my ($token) = $parser->YYCurval;
  my ($what) = $token ? "input: '$token'" : "end of input";
  warn "Syntax error near $what\n";
}

my $input;

sub _Lexer {
  my $self = shift;
  
  for ($input) {
    s{^(\s*)}{};

    return ('',undef) unless $_;

    # dynamically changing the action tables
    return ('INT', $1) if s{^(int\b)}{};
    if (s{^([a-zA-Z_]\w*)}{}) {
      my $id = $1;
      if (m{^[)\s]*[;=]\s*}) {
        # Temptative syntax: It may happen that there are more than two productions involved ...
        #$self->YYSolveConflict([ qw{EXPID DECID} ], ')') = 'DECID';
        $self->YYLRAction([ ')'], 'DECID', 18);
      }
      else {
        $self->YYLRAction([ ')' ], 'EXPID', 18); # the next 'state'
        #$self->YYLRAction([ 'ID', ')' ], 'EXPID');
      }
      return ('ID', $id);
    }

    return ('NUM',$1) if s/^(\d+)//;
    return ($1,$1) if s/^(.)//;
  }
  return ('',undef);
}

sub Run {
  my $debug = shift || 0;
  $debug = 0x1F if $debug;

  $input = <STDIN>;

  my $self = __PACKAGE__->new();

  print $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error, yydebug => $debug,)->str."\n";
}

sub TERMINAL::info { 
  $_[0]->{attr} 
}

Run(@ARGV) unless caller;

=head1  C++ Ambiguities

This grammar models a problematic part of the C++ grammarâ€”the ambiguity between certain
declarations and statements. For example,

     int (x) = y+z;

parses as either an expr or a stmt.


Eyapp detects this as a reduce/reduce conflict:

  State 17 contains 1 reduce/reduce conflict

  State 17:

	expr -> ID .	(Rule 5)
	declarator -> ID .	(Rule 11)

	')'	[reduce using rule 11 (declarator)]
	$default	reduce using rule 5 (expr)

The C++ rule is: take it as a declaration if it looks as a declaration,
otherwise is an expression.

This Eyapp parser solves the problem by dynamically changing the parser
(hacking).

=head1 SEE ALSO

=over 2

=item * L<http://www.gnu.org/software/bison/manual/html_mono/bison.html#GLR-Parsers>

=item * L<http://en.wikipedia.org/wiki/Significantly_Prettier_and_Easier_C%2B%2B_Syntax>

=item * L<http://www.csse.monash.edu.au/~damian/papers/PS/ModestProposal.ps> 

=item * L<http://www.nobugs.org/developer/parsingcpp/>

=item * Edward Willink's "Meta-Compilation for C++" PhD thesis at L<http://www.computing.surrey.ac.uk/Research/CSRG/fog/FogThesis.pdf>

=back

=cut

