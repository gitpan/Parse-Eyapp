# An alternative solution to lexical tie-ins. See also: SemanticInfoInTokens.eyp
# See: http://www.gnu.org/software/bison/manual/html_mono/bison.html#Lexical-Tie_002dins

%strict

%token ID INT INTEGER 
%syntactic token HEX

%right '='
%left '+'

%{
my %st;
%}

%tree bypass alias

%%
stmt:
    decl <* ';'> expr <%name EXPS + ';'>
      {
        $_[2]->{st} = { %st };
        $_[2];
      }
;

decl:
    INT ID <+ ','>
      {
        $st{$_->{attr}} = 1 for $_[2]->children();
      }
;

expr:
    %name ID
    $ID
      {
        my $parser = shift;

        my $hexflag = $parser->{HEXFLAG};
        if ($hexflag and !exists($st{$ID}) and $ID =~ m{^([A-F0-9]+$)}) {
          Parse::Eyapp::Node->new('NUM', sub { $_[0]->{attr} = hex($ID) }); 
        }
        else {
          Parse::Eyapp::Node->new('ID', sub { $_[0]->{attr} = $ID });
        }
      }
  | %name NUM
    INTEGER
  | %name HEX
    HEX '(' { $_[0]->{HEXFLAG} = 1; } $expr ')'
      { 
        $_[0]->{HEXFLAG} = 0; 
        $expr;
      }
  | %name ASSIGN
    $ID '=' expr 
      {
        my $parser = shift;
        my $t = $parser->YYBuildAST(@_);
        # Retype left (TERMINAL) child as ID
        $t->ID->type('ID');
        $t;
      }
  | %name PLUS
    expr '+' expr
;

%%

use Getopt::Long;
use List::Util qw{first};
use Data::Dumper;

sub _Error {
  my($token)=$_[0]->YYCurval;
  my($what)= $token ? "input: '$token'" : "end of input";
  my @expected = $_[0]->YYExpect();

  local $" = ', ';
  warn "Syntax error near $what. Expected one of these tokens: <@expected>\n";
  warn "Remaining input:\n". substr($_[0]->{input}, pos($_[0]->{input}));
  die # Dumper($_[0]->{STACK}[-1])
  ;
}


# Context-dependant lexer
sub lexer {
  my $parser = shift;
  my $hexflag = $parser->{HEXFLAG};

  for ($parser->{input}) {    # contextualize
    m{\G\s*(\#.*)?}gc;

    m{\G(HEX\b|INT\b)}igc and return (uc($1), $1);

    m{(\G\d+)}gc and return ('INTEGER', $hexflag? hex($1) : $1);


    return ('ID', $1) if m{\G([a-zA-Z_]\w*)}gc;

    m{\G(.)}gc         and return ($1, $1);

    return('',undef);
  }
}

sub Run {
    my($self)=shift;
    my $yydebug = shift || 0;

    return $self->YYParse( 
      yylex => \&lexer, 
      yyerror => \&_Error,
      yydebug => $yydebug, # 0x1F
    );
}

sub uploadfile {
  my $file = shift;
  my $msg = shift;

  my $input = '';
  eval {
    $input = Parse::Eyapp::Base::slurp_file($file) 
  };
  if ($@) {
    print $msg;
    local $/ = undef;
    $input = <STDIN>;
  }
  return $input;
}

sub main {
  my $package = shift;

  my $debug = 0;
  my $file = '';
  my $result = GetOptions (
    "debug!" => \$debug,  
    "file=s" => \$file,
  );

  $debug = 0x1F if $debug;
  $file = shift if !$file && @ARGV; 

  my $parser = $package->new();
  my $prompt = "Expressions. Press CTRL-D (Unix) or CTRL-Z (Windows) to finish:\n";
  $parser->{input} = uploadfile($file, $prompt);
  print $parser->Run( $debug )->str,"\n";
}

*TERMINAL::info = *NUM::info = *ID::info = sub {
  $_[0]->{attr}
};

__PACKAGE__->main unless caller();

=head1 THIS EXAMPLE

In this "Calc"-like example we have a language with a special construct C<hex
(hex-expr)>. After the keyword C<hex> comes an C<expression> in parentheses in
which all integers are hexadecimal. In particular, strings in C</[A-F0-9]+/>
like C<A1B> must be treated as an hex integer unless they were previously
declared.

=head1 RUNNING

  Parse-Eyapp/examples/debuggingtut$ eyapp -vb '' DynamicvsTieIns.eyp
  Parse-Eyapp/examples/debuggingtut$ ./DynamicvsTieIns.pm -file inputforsemanticinfo.txt
  EXPS(ASSIGN(ID[A],NUM[12]),ASSIGN(ID[B],NUM[177]),ASSIGN(ID[C],NUM[18]),ASSIGN(ID[B],PLUS(ID[A],ID[C])),ASSIGN(ID[B],PLUS(NUM[13],ID[C])))  
  Parse-Eyapp/examples/debuggingtut$ cat inputforsemanticinfo.txt
  int A,B,C
  A = 12;
  hex(B = B1);
  C = hex(12);
  B = A+C;
  B = HEX(D+C)


=head1 SEE ALSO

=over 2

=item * L<http://www.gnu.org/software/bison/manual/html_mono/bison.html#Lexical-Tie_002dins>

=item * L<http://en.wikipedia.org/wiki/The_lexer_hack>

=item * L<http://eli.thegreenplace.net/2007/11/24/the-context-sensitivity-of-cs-grammar/>

=back
