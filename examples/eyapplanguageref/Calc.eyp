# examples/eyapplanguageref/Calc.eyp
%right  '='
%left   '-' '+'
%left   '*' '/'
%left   NEG
%right  '^'
%{
my %s; # symbol table
%}

%%
start: 
    input { \%s }
;

input: line * 
;

line:       
  '\n'         { undef }
  | exp '\n'   { print "$_[1]\n" if defined($_[1]); $_[1] }
  | error  '\n'
      { 
        $_[0]->YYErrok; 
        undef 
      }
;

exp:
    NUM
  | $VAR                   { $s{$VAR} }
  | $VAR '=' $exp          { $s{$VAR} = $exp }
  | exp.left '+' exp.right { $left + $right }
  | exp.left '-' exp.right { $left - $right }
  | exp.left '*' exp.right { $left * $right }
  | exp.left '/' exp.right         
    {
       $_[3] and return($_[1] / $_[3]);
       $_[0]->YYData->{ERRMSG} = "Illegal division by zero.\n";
       $_[0]->YYError; # Pretend that a syntactic error occurred: _Error will be called
       undef
    }
  | '-' $exp %prec NEG     { -$exp }
  | exp.left '^' exp.right { $left ** $right }
  | '(' $exp ')'           { $exp }
;

%%
use base q{Parse::Eyapp::TailSupport};

__PACKAGE__->lexer( sub {
    my $parser = shift;

    for (${$parser->input}) {
      m{\G[ \t]*(?:#.*)?}gc;
      m{\G([0-9]+(?:\.[0-9]+)?)}gc   and return ('NUM',$1);
      m{\G([A-Za-z][A-Za-z0-9_]*)}gc and return ('VAR',$1);
      m{\G\n}gc                      and do { 
                                        $parser->tokenline(1); 
                                        return ("\n", "\n") 
                                     };
      m{\G(.)}gc                     and return ($1,$1);

      return('',undef);
    }
  }
);

# In case is compiled with eyapp option -b
__PACKAGE__->main unless caller;
