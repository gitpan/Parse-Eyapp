Cannot find page `Parse::Eyapp' at L<> on line 118
Cannot find page `yacc' at L<> on line 118
Cannot find page `yapp' at L<> on line 119
Cannot find page `Language::AttributeGrammar' at L<> on line 634
Cannot find page `Language::AttributeGrammar' at L<> on line 636
Cannot find page `Parse::Eyapp' at L<> on line 1752
Cannot find page `Parse::Yapp' at L<> on line 1767
Cannot find page `Language::AttributeGrammar' at L<> on line 1776
Cannot find page `Parse::RecDescent' at L<> on line 1779
Cannot find page `perlartistic' at L<> on line 1822
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<meta content="text/css" http-equiv="Content-Style-Type">
<meta content="Marek::Pod::HTML 0.49" name="GENERATOR">
<title>eyapptut</title>
</head>
<body>
<a class="POD_NAVLINK" name="Pod_TOP_OF_PAGE"></a>
<h1 class="POD_TITLE">eyapptut</h1>
<hr>
<ul>
<li><a class="POD_NAVLINK" href="#NAME">NAME</a>
<li><a class="POD_NAVLINK" href="#VERSION">VERSION</a>
<li><a class="POD_NAVLINK" href="#SYNOPSIS">SYNOPSIS</a>
<li><a class="POD_NAVLINK" href="#Introduction_to_Pars">Introduction to <code>Parse::Eyapp</code></a>
<li><a class="POD_NAVLINK" href="#Input_from_strings">Input from strings</a>
<li><a class="POD_NAVLINK" href="#Names_for_attributes">Names for attributes</a>
<li><a class="POD_NAVLINK" href="#Lists_and_Optionals">Lists and Optionals</a>
<li><a class="POD_NAVLINK" href="#Default_actions">Default actions</a>
<ul>
<li><a class="POD_NAVLINK" href="#Compiling_with_eyapp">Compiling with <code>eyapp</code></a>
</ul>
<li><a class="POD_NAVLINK" href="#Abstract_Syntax_Tree">Abstract Syntax Trees</a>
<ul>
<li><a class="POD_NAVLINK" href="#Displaying_Trees">Displaying Trees</a>
<li><a class="POD_NAVLINK" href="#TERMINAL_nodes"><code>TERMINAL</code> nodes</a>
<li><a class="POD_NAVLINK" href="#User_Attributes_and_">User Attributes and System Attributes</a>
<li><a class="POD_NAVLINK" href="#Syntactic_and_Semant">Syntactic and Semantic tokens</a>
<li><a class="POD_NAVLINK" href="#Saving_the_Informati">Saving the Information In Syntactic Tokens</a>
<li><a class="POD_NAVLINK" href="#The_directives_synta">The directives <code>%syntactic token</code> and  <code>%semantic token</code></a>
<li><a class="POD_NAVLINK" href="#The_bypass_clause_an">The  <code>bypass</code> clause and the <code>%no bypass</code> directive</a>
<li><a class="POD_NAVLINK" href="#Explictly_building_n">Explictly building nodes with the <code>YYBuildAST</code> method</a>
<li><a class="POD_NAVLINK" href="#The_child_and_descen">The <code>child</code> and <code> descendant</code> methods</a>
<li><a class="POD_NAVLINK" href="#The_alias_clause_of_">The <code>alias</code> clause of the <code>%tree</code> directive</a>
</ul>
<li><a class="POD_NAVLINK" href="#Tree_Regular_Express">Tree Regular Expressions</a>
<ul>
<li><a class="POD_NAVLINK" href="#The_Syntax_of_Treere">The Syntax of Treeregexp</a>
<li><a class="POD_NAVLINK" href="#Separated_Compilatio">Separated Compilation with <code>treereg</code></a>
<li><a class="POD_NAVLINK" href="#Regexp_Treeregexps">Regexp Treeregexps</a>
<li><a class="POD_NAVLINK" href="#Matching_Trees">Matching Trees</a>
<li><a class="POD_NAVLINK" href="#The_SEVERITY_option_">The <code>SEVERITY</code> option of <code>Parse::Eyapp::Treeregexp::new</code></a>
<li><a class="POD_NAVLINK" href="#Array_Treeregexp_Exp">Array Treeregexp Expressions</a>
</ul>
<li><a class="POD_NAVLINK" href="#Translation_Schemes">Translation Schemes</a>
<ul>
<li><a class="POD_NAVLINK" href="#Execution_Stages_of_">Execution Stages of a Translation Scheme</a>
<li><a class="POD_NAVLINK" href="#The_begin_directive">The <code>%begin</code> directive</a>
</ul>
<li><a class="POD_NAVLINK" href="#Scope_Analysis_with_">Scope Analysis with <code>Parse::Eyapp::Scope</code></a>
<li><a class="POD_NAVLINK" href="#SEE_ALSO">SEE ALSO</a>
<li><a class="POD_NAVLINK" href="#REFERENCES">REFERENCES</a>
<li><a class="POD_NAVLINK" href="#AUTHOR">AUTHOR</a>
<li><a class="POD_NAVLINK" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a>
<li><a class="POD_NAVLINK" href="#LICENCE_AND_COPYRIGH">LICENCE AND COPYRIGHT</a>
</ul>
<hr>
<h2 class="POD_HEAD1"><a name="NAME">NAME</a></h2>
<p class="POD_TEXT">
Parse::Eyapp
</p>
<p></p>
<h2 class="POD_HEAD1"><a name="VERSION">VERSION</a></h2>
<p class="POD_TEXT">
1.06503
</p>
<h2 class="POD_HEAD1"><a name="SYNOPSIS">SYNOPSIS</a></h2>
<pre class="POD_VERBATIM">
 use strict;
 use Parse::Eyapp;
 use Parse::Eyapp::Treeregexp;

 sub TERMINAL::info {
   $_[0]{attr}
 }

 my $grammar = q{
   %right  &#39;=&#39;     # Lowest precedence
   %left   &#39;-&#39; &#39;+&#39; # + and - have more precedence than = Disambiguate a-b-c as (a-b)-c
   %left   &#39;*&#39; &#39;/&#39; # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
   %left   NEG     # Disambiguate -a-b as (-a)-b and not as -(a-b)
   %tree           # Let us build an abstract syntax tree ...

   %%
   line: exp &lt;%name EXPRESION_LIST + &#39;;&#39;&gt;  { $_[1] } /* list of expressions separated by &#39;;&#39; */
   ;

   /* The %name directive defines the name of the class to which the node being built belongs */
   exp:
       %name NUM  NUM            | %name VAR   VAR         | %name ASSIGN VAR &#39;=&#39; exp
     | %name PLUS exp &#39;+&#39; exp    | %name MINUS exp &#39;-&#39; exp | %name TIMES  exp &#39;*&#39; exp
     | %name DIV     exp &#39;/&#39; exp | %name UMINUS &#39;-&#39; exp %prec NEG
     |   &#39;(&#39; exp &#39;)&#39;  { $_[2] }  /* Let us simplify a bit the tree */
   ;

   %%
   sub _Error { die &quot;Syntax error near &quot;.($_[0]-&gt;YYCurval?$_[0]-&gt;YYCurval:&quot;end of file&quot;).&quot;\n&quot; }

   sub _Lexer {
     my($parser)=shift; # The parser object

     for ($parser-&gt;YYData-&gt;{INPUT}) {
       s/^\s+//;
       $_ eq &#39;&#39; and return(&#39;&#39;,undef);
       s/^([0-9]+(?:\.[0-9]+)?)// and return(&#39;NUM&#39;,$1);
       s/^([A-Za-z][A-Za-z0-9_]*)// and return(&#39;VAR&#39;,$1);
       s/^(.)//s and return($1,$1);
     }
   }

   sub Run {
       my($self)=shift;
       $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error, );
   }
 }; # end grammar

 our (@all, $uminus);

 Parse::Eyapp-&gt;new_grammar( # Create the parser package/class
   input=&gt;$grammar,
   classname=&gt;&#39;Calc&#39;, # The name of the package containing the parser
   firstline=&gt;7       # String $grammar starts at line 7 (for error diagnostics)
 );
 my $parser = Calc-&gt;new();                # Create a parser
 $parser-&gt;YYData-&gt;{INPUT} = &quot;2*-3+b*0;--2\n&quot;; # Set the input
 my $t = $parser-&gt;Run;                    # Parse it!
 local $Parse::Eyapp::Node::INDENT=2;
 print &quot;Syntax Tree:&quot;,$t-&gt;str;

 # Let us transform the tree. Define the tree-regular expressions ..
 my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
   { #  Example of support code
     my %Op = (PLUS=&gt;&#39;+&#39;, MINUS =&gt; &#39;-&#39;, TIMES=&gt;&#39;*&#39;, DIV =&gt; &#39;/&#39;);
   }
   constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($x), NUM($y))
     =&gt; {
       my $op = $Op{ref($_[0])};
       $x-&gt;{attr} = eval  &quot;$x-&gt;{attr} $op $y-&gt;{attr}&quot;;
       $_[0] = $NUM[0];
     }
   uminus: UMINUS(NUM($x)) =&gt; { $x-&gt;{attr} = -$x-&gt;{attr}; $_[0] = $NUM }
   zero_times_whatever: TIMES(NUM($x), .) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
   whatever_times_zero: TIMES(., NUM($x)) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
   },
   OUTPUTFILE=&gt; &#39;main.pm&#39;
 );
 $p-&gt;generate(); # Create the tranformations

 $t-&gt;s($uminus); # Transform UMINUS nodes
 $t-&gt;s(@all);    # constant folding and mult. by zero

 local $Parse::Eyapp::Node::INDENT=0;
 print &quot;\nSyntax Tree after transformations:\n&quot;,$t-&gt;str,&quot;\n&quot;;
</pre>
<p></p>
<h2 class="POD_HEAD1"><a name="Introduction_to_Pars">Introduction to <code>Parse::Eyapp</code></a></h2>
<p class="POD_TEXT">
Parse::Eyapp (Extended yapp) is a collection of modules
that extends Francois Desarmenien Parse::Yapp 1.05.
Eyapp extends yacc/yapp syntax with 
the functionalities briefly described in this section.
This is an introductory tutorial. For a reference guide
see <u>Parse::Eyapp</u>. If you are not familiar with <u>yacc</u>
or <u>yapp</u> and you can speak Spanish start reading the contents in
<a class="POD_LINK" href="http://nereida.deioc.ull.es/~pl/perlexamples/chapter_parseeyapp.html">http://nereida.deioc.ull.es/~pl/perlexamples/chapter_parseeyapp.html</a>.
</p>
<p></p>
<h2 class="POD_HEAD1"><a name="Input_from_strings">Input from strings</a></h2>
<p class="POD_TEXT">
Grammars can be compiled from a file or from source on the fly
(See the synopsis section for an example).
</p>
<h2 class="POD_HEAD1"><a name="Names_for_attributes">Names for attributes</a></h2>
<p class="POD_TEXT">
Attributes can be referenced by meaningful names instead
of the classic error-prone positional approach using the <b>dot notation</b>
like in:
</p>
<pre class="POD_VERBATIM">
       exp : exp.left &#39;-&#39; exp.right  { $left - $right }
</pre>
<p class="POD_TEXT">
By qualifying the first appearance of the syntactic variable <code>exp</code>
with the notation <code>exp.left</code> we can later refer inside the actions
to the associated attribute using the lexical variable
<code>$left</code>.  The <b>dolar notation</b> <code>$A</code> can be used as an abbreviation
of <code>A.A</code>. For example:
</p>
<pre class="POD_VERBATIM">
       exp:  -&#39; $exp %prec NEG { -$exp }
</pre>
<h2 class="POD_HEAD1"><a name="Lists_and_Optionals">Lists and Optionals</a></h2>
<p class="POD_TEXT">
Lists, optional lists, list separated by tokens, etc. like in the start
rule in the Synopsis example can be used:
</p>
<pre class="POD_VERBATIM">
         line: exp &lt;%name EXPRESION_LIST + &#39;;&#39;&gt;  { $_[1] }
</pre>
<p class="POD_TEXT">
which defines <code>line</code> as the language of non empty lists of <code>exp</code> elements
separated by semicolons. The use of <code>%name EXPRESION_LIST</code> gives a name
to the created list. Actually the right hand side of this production has 
only one element which is the reference to the list.
The associated action <code>{ $_[1] }</code> makes the generated parser to return 
the reference to such list.
</p>
<p class="POD_TEXT">
The former rule
is almost equivalent to:
</p>
<pre class="POD_VERBATIM">
      line: line &#39;;&#39; exp  { push $_[1]-&gt;{children}, $_[3] }
          | exp           { bless { children =&gt; [ $_[1] ] }, &#39;EXPRESION_LIST&#39; }
</pre>
<p></p>
<p></p>
<h2 class="POD_HEAD1"><a name="Default_actions">Default actions</a></h2>
<p class="POD_TEXT">
When no action is specified both <code>yapp</code> and <code>eyapp</code>
implicitly insert the semantic action <code>{ $_[1] }</code>. 
In <code>Parse::Eyapp</code> you can modify such behavior using the <code>%defaultaction { Perl code }</code>
directive. The Perl code that follows the directive is
executed when reducing by any production for which no explicit
action was specified.
See an example that translates an infix expression
like <code>a=b*-3</code> into a postfix expression like <code>a b 3 NEG * = </code>:
</p>
<pre class="POD_VERBATIM">
 # File Postfix.eyp (See the examples/ directory)
 %right  &#39;=&#39;
 %left   &#39;-&#39; &#39;+&#39;
 %left   &#39;*&#39; &#39;/&#39;
 %left   NEG

 %defaultaction { return  &quot;$left $right $op&quot;; }

 %%
 line: $exp  { print &quot;$exp\n&quot; }
 ;

 exp:        $NUM  { $NUM }
         |   $VAR  { $VAR }
         |   VAR.left &#39;=&#39;.op exp.right
         |   exp.left &#39;+&#39;.op exp.right
         |   exp.left &#39;-&#39;.op exp.right
         |   exp.left &#39;*&#39;.op exp.right
         |   exp.left &#39;/&#39;.op exp.right
         |   &#39;-&#39; $exp %prec NEG { &quot;$exp NEG&quot; }
         |   &#39;(&#39; $exp &#39;)&#39; { $exp }
 ;

 %%

 # Support subroutines as in the Synopsis example
 ...
</pre>
<h3 class="POD_HEAD2"><a name="Compiling_with_eyapp">Compiling with <code>eyapp</code></a></h3>
<p class="POD_TEXT">
The file containing the <code>Eyapp</code> program must be compiled with <code>eyapp</code>:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; eyapp Postfix.eyp
</pre>
<p class="POD_TEXT">
Next, you have to write a client program:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n usepostfix.pl
      1  #!/usr/bin/perl -w
      2  use strict;
      3  use Postfix;
      4
      5  my $parser = new Postfix();
      6  $parser-&gt;Run;
</pre>
<p class="POD_TEXT">
Now we can run the client program:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; usepostfix.pl
 Write an expression: -(2*a-b*-3)
 2 a * b 3 NEG * - NEG
</pre>
<h2 class="POD_HEAD1"><a name="Abstract_Syntax_Tree">Abstract Syntax Trees</a></h2>
<p class="POD_TEXT">
<code>Parse::Eyapp</code> facilitates the construction of concrete syntax trees and 
abstract syntax trees (abbreviated AST from now on) through the <code>%tree</code>
directive. 
Nodes in the AST are blessed in the production
<code>name</code>. 
By default the name of a production is the concatenation
of the left hand side and the production number. The production number
is the ordinal number of the production as they appear in the associated 
<code>.output</code> file (see option <code>-v</code> of <a class="POD_LINK" href="eyapp.html">eyapp</a>) However, a production can be 
<i>named</i> using the <code>%name</code> directive. Therefore, in the following
code:
</p>
<pre class="POD_VERBATIM">
 exp:
        %name NUM  NUM            
      | %name VAR   VAR         
      | %name ASSIGN VAR &#39;=&#39; exp
      . .............................
      | %name UMINUS &#39;-&#39; exp %prec NEG
      |   &#39;(&#39; exp &#39;)&#39;  { $_[2] }  /* Let us simplify a bit the tree */
</pre>
<p class="POD_TEXT">
we are explictly naming the productions. Thus, the node corresponding to the 
production <code>exp: VAR &#39;=&#39; exp</code> will be named <code>ASSIGN</code>.
Explicit actions can be specified by the programmer like in
</p>
<pre class="POD_VERBATIM">
      |   &#39;(&#39; exp &#39;)&#39;  { $_[2] }  /* Let us simplify a bit the tree */
</pre>
<p class="POD_TEXT">
the action receives as arguments the references to the children nodes already 
built. The programmer can influence the shape of the tree by inserting
this explicit actions. In the example the programmer has decided to simplify the 
syntax tree: the nodes associated with the parenthesis are 
discarded and the reference to the subtree containing the proper
expression is returned.
</p>
<p class="POD_TEXT">
When a <i>explicit user action</i> returns s.t. that is not a reference
no child will be inserted in the father of the current
production.
</p>
<h3 class="POD_HEAD2"><a name="Displaying_Trees">Displaying Trees</a></h3>
<p class="POD_TEXT">
All the node classes build by <code>%tree</code>
inherit from <code>Parse::Eyapp::Node</code> and consequently have
acces to the methods provided in such module. Among them is the <code>str</code> method
which dumps the tree. The <i>str</i> method traverses the syntax tree dumping the type
of the node being visited in a string. If the node has a method <code>info</code> it will
be executed and its result concatenated to the string. Thus, in the Synopsis
example, by adding the <code>info</code> method to the class <code>TERMINAL</code>:
</p>
<pre class="POD_VERBATIM">
 sub TERMINAL::info {
   $_[0]{attr}
 }
</pre>
<p class="POD_TEXT">
we achieve the insertion of attributes in the string build 
by <code>str</code> (see the partial output of <code>synopsis.pl</code> in section
<a class="POD_LINK" href="#Syntactic_and_Semant">Syntactic and Semantic tokens</a>).
</p>
<p class="POD_TEXT">
The existence of some methods (like <code>footnote</code>) and
the values of some package variables
influence the behavior of <code>str</code>. Among the most
important are:
</p>
<pre class="POD_VERBATIM">
  @PREFIXES = qw(Parse::Eyapp::Node::); # Prefixes to supress 
  $INDENT = 0; # 0 = compact, 1 = indent, 2 = indent and include Types in closing parenthesis
  $STRSEP = &#39;,&#39;;
  $DELIMITER = &#39;[&#39;;
  $FOOTNOTE_HEADER = &quot;\n---------------------------\n&quot;;
  $FOOTNOTE_SEP = &quot;)\n&quot;;
  $FOOTNOTE_LEFT = &#39;^{&#39;;
  $FOOTNOTE_RIGHT = &#39;}&#39;;
  $LINESEP = 4;
</pre>
<h3 class="POD_HEAD2"><a name="TERMINAL_nodes"><code>TERMINAL</code> nodes</a></h3>
<p class="POD_TEXT">
Nodes named <code>TERMINAL</code> correspond to 
tokens provided by the lexical analyzer. They are <code>Parse::Eyapp::Node</code>
nodes (hashes) with an attribute <code>attr</code> holding the attribute provided
by the lexical analyzer. The <code>attr</code> method can be used to get/set the 
attribute.
</p>
<h3 class="POD_HEAD2"><a name="User_Attributes_and_">User Attributes and System Attributes</a></h3>
<p class="POD_TEXT">
All the nodes in the AST are <code>Parse::Eyapp::Node</code> nodes.
They are hashes that the user can decorate with new keys/attributes.
The only reserved words are those listed in the reference section.
Basically they have a <code>children</code> key. <code>TERMINAL</code>  nodes have the 
<code>attr</code> key.
</p>
<p></p>
<h3 class="POD_HEAD2"><a name="Syntactic_and_Semant">Syntactic and Semantic tokens</a></h3>
<p class="POD_TEXT">
<code>Parse::Eyapp</code> diferences between <code>syntactic tokens</code>
and <code>semantic tokens</code>. By default all tokens
declared using string notation (i.e. between quotes
like <code>&#39;+&#39;</code>, <code>&#39;=&#39;</code>, in the Synopsis example)
are considered <code>syntactic tokens</code>. Tokens declared by an identifier
(like <code>NUM</code> or <code>VAR</code> in the Synopsis example) are by default considered
<code>semantic tokens</code>. <b>Syntactic tokens are eliminated when building the 
syntactic tree</b>. Thus, the first print in the former Synopsis example:
</p>
<pre class="POD_VERBATIM">
  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*-3+b*0;--2\n&quot;; 
  my $t = $parser-&gt;Run;                    
  local $Parse::Eyapp::Node::INDENT=2;
  print &quot;Syntax Tree:&quot;,$t-&gt;str;
</pre>
<p></p>
<p class="POD_TEXT">
gives as result the following output:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; synopsis.pl
 Syntax Tree:
 EXPRESION_LIST(
   PLUS(
     TIMES(
       NUM(
         TERMINAL[2]
       ),
       UMINUS(
         NUM(
           TERMINAL[3]
         )
       ) # UMINUS
     ) # TIMES,
     TIMES(
       VAR(
         TERMINAL[b]
       ),
       NUM(
         TERMINAL[0]
       )
     ) # TIMES
   ) # PLUS,
   UMINUS(
     UMINUS(
       NUM(
         TERMINAL[2]
       )
     ) # UMINUS
   ) # UMINUS
 ) # EXPRESION_LIST
</pre>
<h3 class="POD_HEAD2"><a name="Saving_the_Informati">Saving the Information In Syntactic Tokens</a></h3>
<p class="POD_TEXT">
The reason for the adjective <code>%syntactic</code> applied to a token is to 
state that the token influences the shape of the syntax tree
but carries no other information. When the tree is built
the node corresponding to the token is discarded.
</p>
<p class="POD_TEXT">
Sometimes the difference between syntactic and semantic 
tokens is blurred. For example the line number associated
with an instance of the syntactic token <code>&#39;+&#39;</code> can be used later
-say during type checking- to emit a more accurate error
diagnostic. But if the node was discarded the information
about that line number is no longer available.
When building the syntax tree <code>Parse::Eyapp</code> (namely
the method <code>Parse::Eyapp::YYBuildAST</code>) checks 
a <code>TERMINAL::save_attributes</code> method exists and if so
it will be called when visiting a syntactic terminal. 
The method receives as argument - additionally
to the reference to the <code>TERMINAL</code> node - a reference
to the node associated with the left hand side of the
production. Here is an example (file <code>examples/Types.eyp</code>)
of use:
</p>
<pre class="POD_VERBATIM">
  sub TERMINAL::save_attributes {
    # $_[0] is a syntactic terminal
    # $_[1] is the father.
    push @{$_[1]-&gt;{lines}}, $_[0]-&gt;[1]; # save the line!
  }
</pre>
<h3 class="POD_HEAD2"><a name="The_directives_synta">The directives <code>%syntactic token</code> and  <code>%semantic token</code></a></h3>
<p class="POD_TEXT">
The new token declaration directives <code>%syntactic token</code> and
<code>%semantic token</code> can change the status of a token.
For example (file <code>15treewithsyntactictoken.pl</code> in the <code>examples/</code> directory), 
given the grammar:
</p>
<pre class="POD_VERBATIM">
   %syntactic token b
   %semantic token &#39;a&#39; &#39;c&#39;
   %tree

   %%

   S: %name ABC
        A B C
    | %name BC
        B C
   ;

   A: %name A
        &#39;a&#39;
   ;

   B: %name B
        b
   ;

   C: %name C
       &#39;c&#39;
   ;
   %%
</pre>
<p class="POD_TEXT">
the tree build for input <code>abc</code> will be <code>ABC(A(TERMINAL),B,C(TERMINAL))</code>.
</p>
<h3 class="POD_HEAD2"><a name="The_bypass_clause_an">The  <code>bypass</code> clause and the <code>%no bypass</code> directive</a></h3>
<p class="POD_TEXT">
The shape of the tree can be also modified using some <code>%tree</code> clauses
as <code>%tree bypass</code> which will produce an automatic <i>bypass</i> of any
node with only one child at tree-construction-time.
</p>
<p class="POD_TEXT">
A <i>bypass operation</i> consists in <i>returning the only child 
of the node being visited to the father of the node and re-typing (re-blessing)
the node in the name of the production</i> (if a name is provided).
</p>
<p class="POD_TEXT">
A node may have only one child at tree-construction-time for one of
two reasons.
</p>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="The_first_occurs_whe"><p>The first occurs when the right hand side of the production
was already unary like in:</p></a>
<pre class="POD_VERBATIM">
                           exp:
                               %name NUM  NUM
</pre>
<p class="POD_TEXT">
Here the <code>NUM</code> node will be bypassed and the child <code>TERMINAL</code> built
from the information provided by the lexical analyzer will be renamed
as <code>NUM</code>.
</p>
<li class="POD_ITEM"><a name="Another_reason_for_a"><p>Another reason for a node to be <i>bypassed</i> is  the fact that though the right
hand side of the production may have more than one symbol, 
only one of them is not a syntactic token
like in:</p></a>
<pre class="POD_VERBATIM">
                           exp: &#39;(&#39; exp &#39;)&#39;
</pre>
</ul>
<p class="POD_TEXT">
As consequence of the blind application of the <i>bypass rule</i>
undesired bypasses may occur like in
</p>
<pre class="POD_VERBATIM">
                           exp : %name UMINUS
                                 &#39;-&#39; $exp %prec NEG
</pre>
<p class="POD_TEXT">
though the right hand side has two symbols, token <code>&#39;-&#39;</code> is
a syntactic token and therefore only <code>exp</code> is left. The <i>bypass</i>
operation will be applied when building this node.
This <i>bypass</i> can be avoided applying the <code>no bypass ID</code> directive to the corresponding 
production:
</p>
<pre class="POD_VERBATIM">
                           exp : %no bypass UMINUS
                                 &#39;-&#39; $exp %prec NEG
</pre>
<p class="POD_TEXT">
The following example is the equivalent of the <i>Synopsis example</i>
but using the <code>bypass</code> clause instead:
</p>
<pre class="POD_VERBATIM">
 use Parse::Eyapp;
 use Parse::Eyapp::Treeregexp;

 sub TERMINAL::info { $_[0]{attr} }
 { no warnings; *VAR::info = *NUM::info = \&amp;TERMINAL::info; }

 my $grammar = q{
   %right  &#39;=&#39;     # Lowest precedence
   %left   &#39;-&#39; &#39;+&#39; 
   %left   &#39;*&#39; &#39;/&#39; 
   %left   NEG     # Disambiguate -a-b as (-a)-b and not as -(a-b)
   %tree bypass    # Let us build an abstract syntax tree ...

   %%
   line: exp &lt;%name EXPRESION_LIST + &#39;;&#39;&gt;  { $_[1] } 
   ;

   exp:
       %name NUM  NUM            | %name VAR   VAR         | %name ASSIGN VAR &#39;=&#39; exp
     | %name PLUS exp &#39;+&#39; exp    | %name MINUS exp &#39;-&#39; exp | %name TIMES  exp &#39;*&#39; exp
     | %name DIV     exp &#39;/&#39; exp
     | %no bypass UMINUS
       &#39;-&#39; $exp %prec NEG
     |   &#39;(&#39; exp &#39;)&#39;
   ;

   %%
   # sub _Error, _Lexer and Run like in the synopsis example
   # ...
 }; # end grammar

 our (@all, $uminus);

 Parse::Eyapp-&gt;new_grammar( # Create the parser package/class
   input=&gt;$grammar,
   classname=&gt;&#39;Calc&#39;, # The name of the package containing the parser
   firstline=&gt;7       # String $grammar starts at line 7 (for error diagnostics)
 );
 my $parser = Calc-&gt;new();                # Create a parser
 $parser-&gt;YYData-&gt;{INPUT} = &quot;a=2*-3+b*0\n&quot;; # Set the input
 my $t = $parser-&gt;Run;                    # Parse it!

 print &quot;\n************\n&quot;.$t-&gt;str.&quot;\n************\n&quot;;

 # Let us transform the tree. Define the tree-regular expressions ..
 my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
   { #  Example of support code
     my %Op = (PLUS=&gt;&#39;+&#39;, MINUS =&gt; &#39;-&#39;, TIMES=&gt;&#39;*&#39;, DIV =&gt; &#39;/&#39;);
   }
   constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM, NUM)
     =&gt; {
       my $op = $Op{ref($_[0])};
       $NUM[0]-&gt;{attr} = eval  &quot;$NUM[0]-&gt;{attr} $op $NUM[1]-&gt;{attr}&quot;;
       $_[0] = $NUM[0];
     }
   zero_times_whatever: TIMES(NUM, .) and { $NUM-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
   whatever_times_zero: TIMES(., NUM) and { $NUM-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
   uminus: UMINUS(NUM) =&gt; { $NUM-&gt;{attr} = -$NUM-&gt;{attr}; $_[0] = $NUM }
   },
   OUTPUTFILE=&gt; &#39;main.pm&#39;
 );
 $p-&gt;generate(); # Create the tranformations

 $t-&gt;s(@all);    # constant folding and mult. by zero

 print $t-&gt;str,&quot;\n&quot;;
</pre>
<p class="POD_TEXT">
when running this example we obtain the following output:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; bypass.pl

 ************
 EXPRESION_LIST(ASSIGN(TERMINAL[a],PLUS(TIMES(NUM[2],UMINUS(NUM[3])),TIMES(VAR[b],NUM[0]))))
 ************
 EXPRESION_LIST(ASSIGN(TERMINAL[a],NUM[-6]))
</pre>
<p class="POD_TEXT">
As you can see the trees are more compact when using the <code>bypass</code> directive.
</p>
<h3 class="POD_HEAD2"><a name="Explictly_building_n">Explictly building nodes with the <code>YYBuildAST</code> method</a></h3>
<p class="POD_TEXT">
Sometimes the best time to decorate a node with some
attributes is just after being built.
In such cases the programmer can take <i>manual control</i>
building the node with <code>YYBuildAST</code> to 
inmediately proceed to decorate it.
</p>
<p class="POD_TEXT">
The following example illustrates the situation:
</p>
<pre class="POD_VERBATIM">
 Variable:
     %name  VARARRAY
     $ID (&#39;[&#39; binary &#39;]&#39;) &lt;%name INDEXSPEC +&gt;
       {
         my $self = shift;
         my $node =  $self-&gt;YYBuildAST(@_);
         $node-&gt;{line} = $ID-&gt;[1];
         return $node;
       }
</pre>
<p class="POD_TEXT">
This example defines the expression to access an array element 
as an identifier followed by
a non empty list of binary expressions. The node corresponding
to the list of indices has been named <code>INDEXSPEC</code>.
</p>
<p class="POD_TEXT">
When no explicit action is
inserted a binary node will be built having as first child the node
corresponding to the identifier <code>$ID</code> and as second child the reference 
to the list of binary expressions. However, the programmer wants to decorate
the node being built with a <code>line</code> attribute holding the line number in the source
code where the identifier being used appears. The call to the <code>Parse::Eyapp::Driver</code>
method <code>YYBuildAST</code> does the job of building the node. After
that the node can be decorated and returned.
</p>
<p class="POD_TEXT">
Actually, the <code>%tree</code> directive is semantically equivalent to:
</p>
<pre class="POD_VERBATIM">
  %default action { goto &amp;Parse::Eyapp::Driver::YYBuildAST }
</pre>
<h3 class="POD_HEAD2"><a name="The_child_and_descen">The <code>child</code> and <code> descendant</code> methods</a></h3>
<p class="POD_TEXT">
Access to the children of the AST is achieved through the <code>children</code> and <code>child</code>
methods. More general is the <code> descendant</code> method that
returns the descendant of a node given its coordinates. See a session
with the debugger:
</p>
<pre class="POD_VERBATIM">
   DB&lt;7&gt; x $t-&gt;child(0)-&gt;child(0)-&gt;child(1)-&gt;child(0)-&gt;child(2)-&gt;child(1)-&gt;str
 0  &#39;
 BLOCK[8:4:test]^{0}(
   CONTINUE[10,10]
 )
   DB&lt;8&gt; x $t-&gt;descendant(&#39;.0.0.1.0.2.1&#39;)-&gt;str
 0  &#39;
 BLOCK[8:4:test]^{0}(
   CONTINUE[10,10]
</pre>
<h3 class="POD_HEAD2"><a name="The_alias_clause_of_">The <code>alias</code> clause of the <code>%tree</code> directive</a></h3>
<p class="POD_TEXT">
There are occasions however where access by name to the children may be preferable.
The use of the <code>alias</code> clause with the <code>%tree</code> directive creates accessors
to the children with names specified by the programmer. The dot and dolar notations
are used for this. When dealing with a production like:
</p>
<pre class="POD_VERBATIM">
                       A: 
                          %name A_Node
                          Node B.bum N.pum $Chip
</pre>
<p class="POD_TEXT">
methods <code>bum</code>, <code>pum</code> and <code>Chip</code> will be created for the class <code>A_Node</code>.
Those methods wil provide access to the respective child (first, second and third in
the example). The methods are build at compile-time and therefore later 
transformations of the AST modifying the order of the children may 
invalidate the use of these getter-setters.
</p>
<p class="POD_TEXT">
As an example, the CPAN module <u>Language::AttributeGrammar</u> provides
AST decorators from an attribute grammar specification of the AST.
To work  <u>Language::AttributeGrammar</u> requires named access to the children
of the AST nodes. Follows an example of a small calculator:
</p>
<pre class="POD_VERBATIM">
 use Parse::Eyapp;
 use Language::AttributeGrammar;

 my $grammar = q{
 ... # priority declarations. Like in previous examples
 %tree bypass alias

 %%
 line: $exp  { $_[1] }
 ;

 exp:
     %name NUM
           $NUM
         | %name VAR
           $VAR
     ............ # as in the bypass example
 }; # end grammar

 Parse::Eyapp-&gt;new_grammar(
   input=&gt;$grammar, classname=&gt;&#39;Rule6&#39;, firstline =&gt;7,
 );
 my $parser = Rule6-&gt;new();
 $parser-&gt;YYData-&gt;{INPUT} = &quot;a = -(2*3+5-1)\n&quot;;
 my $t = $parser-&gt;Run;
 my $attgram = new Language::AttributeGrammar &lt;&lt;&#39;EOG&#39;;
 # Compute the expression
 NUM:    $/.val = { $&lt;attr&gt; }
 TIMES:  $/.val = { $&lt;left&gt;.val * $&lt;right&gt;.val }
 PLUS:   $/.val = { $&lt;left&gt;.val + $&lt;right&gt;.val }
 MINUS:  $/.val = { $&lt;left&gt;.val - $&lt;right&gt;.val }
 UMINUS: $/.val = { -$&lt;exp&gt;.val }
 ASSIGN: $/.val = { $&lt;exp&gt;.val }
 EOG

 my $res = $attgram-&gt;apply($t, &#39;val&#39;);
</pre>
<h2 class="POD_HEAD1"><a name="Tree_Regular_Express">Tree Regular Expressions</a></h2>
<p class="POD_TEXT">
<code>Parse::Eyapp</code> introduces a new language
called <i>Tree Regular Expressions</i> that easies the 
transformation of trees. Let us recall the previous
example used in the <code>bypass</code> section:
</p>
<pre class="POD_VERBATIM">
 my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
   { #  Example of support code
     my %Op = (PLUS=&gt;&#39;+&#39;, MINUS =&gt; &#39;-&#39;, TIMES=&gt;&#39;*&#39;, DIV =&gt; &#39;/&#39;);
   }
   constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM, NUM)
     =&gt; {
       my $op = $Op{ref($_[0])};
       $NUM[0]-&gt;{attr} = eval  &quot;$NUM[0]-&gt;{attr} $op $NUM[1]-&gt;{attr}&quot;;
       $_[0] = $NUM[0];
     }
   zero_times_whatever: TIMES(NUM, .) and { $NUM-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
   whatever_times_zero: TIMES(., NUM) and { $NUM-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
   uminus: UMINUS(NUM) =&gt; { $NUM-&gt;{attr} = -$NUM-&gt;{attr}; $_[0] = $NUM }
   },
   OUTPUTFILE=&gt; &#39;main.pm&#39;
 );
 $p-&gt;generate(); # Create the tranformations

 $t-&gt;s(@all);    # constant folding and mult. by zero
</pre>
<p class="POD_TEXT">
The call to the constructor <code>new</code> builds a <code>Parse::Eyapp::Treeregexp</code> object.
The subsequent call to the method <code>$p-&gt;generate</code> compiles the object producing
tree-transformations built according to the specification
given in the treeregexp program. A tree transformation is a <code>Parse::Eyapp::YATW</code> 
object. The example contains four tree programa transformations
named <code>constantfold</code>, <code>zero_times_whatever</code>, <code>whatever_times_zero</code>
and &lt;uminus&gt;. These transformations can be grouped in transformation 
families. Such families of transformations can be applied 
to any <code>Parse::Eyapp::Node</code> trees.
An special variable <code>@PACKAGE::all</code> refers to the whole set of transformations
in the program.
Here <code>PACKAGE</code> refers to the package where the transformations live.
When no <code>PACKAGE</code> argument is specified in the call to <code>new</code> - as is the case in this example -
the package of the caller is used instead.
The call <code>$t-&gt;s(@all)</code> proceeds to the execution of the method <code>s</code> (for
substitution) using
all the specified transformations. The transformations will be iteratively applied
to all nodes of the tree until there are no changes.
Summarizing, that means that
</p>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="All"><p>All 
<code>UMINUS</code> nodes whose only child
is a number <code>NUM</code> will be substituted by the  <code>NUM</code> node but with the sign changed</p></a>
<li class="POD_ITEM"><a name="Constant_folding_wil"><p>Constant folding will be applied: trees representing
constants expressions will be substituted by a <code>NUM</code> node representing its value</p></a>
<li class="POD_ITEM"><a name="All_the_TIMES_nodes_"><p>All the <code>TIMES</code> nodes with one child holding the value 0 will be substituted
by that child</p></a>
</ul>
<h3 class="POD_HEAD2"><a name="The_Syntax_of_Treere">The Syntax of Treeregexp</a></h3>
<p class="POD_TEXT">
The example illustrates the syntax of the language. A tree transformation
conforms to the syntax:
</p>
<pre class="POD_VERBATIM">
  treeregexp: 
      IDENT &#39;:&#39; treereg (&#39;and&#39; CODE)?  (&#39;=&gt;&#39; CODE)?
</pre>
<p class="POD_TEXT">
like in:
</p>
<pre class="POD_VERBATIM">
 zero_times_whatever: TIMES(NUM, .) and { $NUM-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
</pre>
<p class="POD_TEXT">
The <code>IDENT</code> is the name given to the tree transformation. A tree transformation
is actually a <code>Parse::Eyapp::YATW</code> object. 
After generation time two package objects are created per transformation:
</p>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="A_subroutine_with_na"><p>A subroutine with name <code>zero_times_whatever</code> holding the actual 
code for the tree transformation will be available and</p></a>
<li class="POD_ITEM"><a name="A_scalar_variable_na"><p>A scalar variable named <code>$zero_times_whatever</code> will refer to the 
<code>Parse::Eyapp::YATW</code>  tree transformation object.</p></a>
</ul>
<p class="POD_TEXT">
These names
live in the package specified by the user in the call to <code>new</code> through the <code>PACKAGE</code>
argument. When
no package name is specified the name of the caller package is used instead.
</p>
<p class="POD_TEXT">
After the <code>IDENT</code> and the colon comes the <b>treeregexp</b>. The treeregexp 
is a term, that is a parenthesized description of the shape of the tree
like <code>TIMES(NUM, .)</code> which says: <i>match nodes of type</i> <code>TIMES</code>
<i>whose left child is a</i> <code>NUM</code> <i>and whose right child is whatever</i>.
The dot stands for <i>whatever</i> and is a treeregexp that matches any node.
</p>
<p class="POD_TEXT">
Then comes the reserved word <code>and</code> and some Perl code specifying
the semantic conditions for the node being visited to match
</p>
<pre class="POD_VERBATIM">
                              { $NUM-&gt;{attr} == 0 }
</pre>
<p class="POD_TEXT">
The code can access to the different subtrees using lexical variables
whose names match the type of the node. Thus, in the example:
</p>
<pre class="POD_VERBATIM">
 zero_times_whatever: TIMES(NUM, .) and { $NUM-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
</pre>
<p class="POD_TEXT">
variable <code>$NUM</code> refers to the left child while variables 
<code>$TIMES</code> and <code>$_[0]</code> will refer refer to the node being visited.
When more than one node of the same
type exists (for instance <code>TIMES(NUM,NUM)</code>)
the associated lexical variable changes its type from scalar to array and thus
if several <code>NUM</code> nodes appear in the term we will speak about 
<code>$NUM[0]</code>, <code>$NUM[1]</code>, etc.
</p>
<h3 class="POD_HEAD2"><a name="Separated_Compilatio">Separated Compilation with <code>treereg</code></a></h3>
<p class="POD_TEXT">
A Treeregexp program can be isolated in a file
an compiled with the program <code>treereg</code>.
The default extension is <code>.trg</code>.
See the following example:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n Shift.trg
  1  # File: Shift.trg
  2  {
  3    sub log2 {
  4      my $n = shift;
  5      return log($n)/log(2);
  6    }
  7
  8    my $power;
  9  }
 10  mult2shift: TIMES($e, NUM($m)) and { $power = log2($m-&gt;{attr}); (1 &lt;&lt; $power) == $m-&gt;{attr} }
 11    =&gt; {
 12      $_[0]-&gt;delete(1);
 13      $_[0]-&gt;{shift} = $power;
 14      $_[0]-&gt;type(&#39;SHIFTLEFT&#39;);
 15    }
</pre>
<p></p>
<p class="POD_TEXT">
Note that auxiliary support code can be inserted at any point
between transformations (lines 2-6). The code will be inserted (without 
the defining curly brackets) at that point. Note also
that the lexical variable <code>$power</code> is visible
inside the definition of the <code>mult2shift</code> transformation.
</p>
<p class="POD_TEXT">
A treeregexp like <code>$e</code> matches any node. A reference to the node
is saved in the lexical variable <code>$e</code>. The scope of the variable
<code>$e</code> is the current tree transformation, i.e. <code>mult2shift</code>.
Such kind of treeregexps are called <b>scalar treeregexp</b>s.
</p>
<p class="POD_TEXT">
The call to the <code>delete</code> method at line 12 deletes 
the second child of the node being visited (i.e. <code>NUM($m)</code>).
</p>
<p class="POD_TEXT">
The call to <code>type</code> at line 14 retypes the node
as a <code>SHIFTLEFT</code> node.
</p>
<p class="POD_TEXT">
The program is compiled using the script <code>treereg</code>:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; treereg Shift
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; ls -ltr | tail -1
 -rw-rw----  1 pl users   1405 2006-11-06 14:09 Shift.pm
</pre>
<p class="POD_TEXT">
The module <code>Shift.pm</code> contains the code implementing
the tree transformations.
</p>
<p class="POD_TEXT">
The client program follows:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n useruleandshift.pl
  1  #!/usr/bin/perl -w
  2  use strict;
  3  use Rule6;
  4  use Shift;
  5  { no warnings; *TERMINAL::info = \&amp;TERMINAL::attr; }
  6
  7  sub SHIFTLEFT::info { $_[0]{shift} }
  8
  9  $Data::Dumper::Indent = 1;
 10  my $parser = new Rule6();
 11  $parser-&gt;YYData-&gt;{INPUT} = &lt;&gt;;
 12  my $t = $parser-&gt;Run;
 13  print &quot;***********\n&quot;,$t-&gt;str,&quot;\n&quot;;
 14  $t-&gt;s(@Shift::all);
 15  print &quot;***********\n&quot;,$t-&gt;str,&quot;\n&quot;;
</pre>
<p class="POD_TEXT">
Multiplications by a power of two are substituted by the corresponding shifts:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; useruleandshift.pl
 a=b*8
 ***********
 ASSIGN(TERMINAL[a],TIMES(VAR(TERMINAL[b]),NUM(TERMINAL[8])))
 ***********
 ASSIGN(TERMINAL[a],SHIFTLEFT[3])
</pre>
<h3 class="POD_HEAD2"><a name="Regexp_Treeregexps">Regexp Treeregexps</a></h3>
<p class="POD_TEXT">
We can use an ordinary regular expression <code>regexp</code> inside 
the term part of a treeregexp.
The <code>constantfold</code> transformation in the Synopsis example
shows how:
</p>
<pre class="POD_VERBATIM">
   constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($x), NUM($y))
     =&gt; {
       my $op = $Op{ref($bin)};
       $x-&gt;{attr} = eval  &quot;$x-&gt;{attr} $op $y-&gt;{attr}&quot;;
       $_[0] = $NUM[0];
     }
</pre>
<p class="POD_TEXT">
The regexp is specified between division slashes <code>/</code>.
It is legal to specify options after the second slash (like <code>e</code>, <code>i</code>, etc.).
The optional identifier <code>bin</code> after the regexp indicates the name for the lexical
variable holding a copy that references the node.
If no identifier is specified, the special variable <code>$W</code> is used instead.
If the treeregexp has several anonymous regexp or dot treeregexps
they will be stored in the array variable <code>@W</code>.
</p>
<p class="POD_TEXT">
The operation of the ordinary string oriented regexps are slightly modified
when they are used inside a treeregexp.
<b>by default the option</b> 
<code>x</code> 
<b>will be assumed</b>.
The treeregexp compiler will automatically insert it.
Use the new option <code>X</code> (upper case X) if you want to supress such behavior.
<b>There is no need also to insert</b> <code>\b</code> 
<b>word anchors</b> to delimit identifiers:
all the identifiers in a regexp treeregexp are automatically
surrounded by <code>\b</code>. Use the option <code>B</code> (upper case B)
to supress this behavior.
</p>
<p class="POD_TEXT">
The following fragment of the type checking stage of a simple 
compiler shows that <code>x</code> is implictly assumed:
</p>
<pre class="POD_VERBATIM">
 # Binary Operations
 bin: / PLUS
       |MINUS
       |TIMES
       |DIV
       |MOD
       |GT
       |GE
       |LE
       |EQ
       |NE
       |LT
       |AND
       |EXP
       |OR
      /($x, $y)
   =&gt; {
     $x = char2int($_[0], 0);
     $y = char2int($_[0], 1);

     if (($x-&gt;{t} == $INT) and ( $y-&gt;{t} == $INT)) {
       $_[0]-&gt;{t} = $INT;
       return 1;
     }
     type_error(&quot;Incompatible types with operator &#39;&quot;.($_[0]-&gt;lexeme).&quot;&#39;&quot;, $_[0]-&gt;line);
   }
</pre>
<p class="POD_TEXT">
With the natural Perl regexp semantic the language reserved
word <code>WHILE</code> would match the regexp (see the <code>LE</code> for <i>less or equal</i>)
leading to an erroneous
type checking. The automatic insertion of word anchors prevent it.
</p>
<h3 class="POD_HEAD2"><a name="Matching_Trees">Matching Trees</a></h3>
<p class="POD_TEXT">
Both the transformation objects in <code>Parse::Eyapp::YATW</code>
and the nodes in <code>Parse::Eyapp::Node</code> have a method 
named <code>m</code> for matching.
</p>
<p class="POD_TEXT">
For a <code>Parse::Eyapp::YATW</code> object, the method -when called
in a list context- returns a list of 
<code>Parse::Eyapp::Node::Match</code> nodes referencing
the nodes of the actual tree that have matched.
The nodes in the list are organized in a hierarchy.
</p>
<p class="POD_TEXT">
The nodes are sorted in the list of trees (a forest)
according to a depth-first visit of the actual tree <code>$t</code>.
</p>
<p class="POD_TEXT">
In a scalar context <code>m</code> returns the first element of
the list.
</p>
<p class="POD_TEXT">
Let us denote by <code>$t</code> the actual tree being searched
and <code>$r</code> one of the <code>Parse::Eyapp::Node::Match</code>
nodes in the resulting forest.
Then we have the following methods:
</p>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="The_method_r_node_re"><p>The method <code>$r-&gt;node</code> return the node <code>$t</code> of the actual 
tree that matched</p></a>
<li class="POD_ITEM"><a name="The_method_r_father_"><p>The method <code>$r-&gt;father</code> returns the tree in the matching forest.
The father is defined by this property:
<code>$r-&gt;father-&gt;node</code> is the nearest ancestor of
<code>$r-&gt;node</code> that matched with the treeregexp pattern.
That is, there is no ancestor that matched between
<code>$r-&gt;node</code> and <code>$r-&gt;father-&gt;node</code>.
Otherwise <code>$r-&gt;father</code> is <code>undef</code></p></a>
<li class="POD_ITEM"><a name="_"></a>
<p class="POD_TEXT">
The method <code>$r-&gt;coord</code> returns the coordinates of the actual tree
that matched using s.t similar to the Dewey notation.
for example, the coordinate <code>&quot;.1.3.2&quot;</code> 
denotes the node <code>$t-&gt;child(1)-&gt;child(3)-&gt;child(2)</code>, where <code>$t</code>
is the root of the search.
</p>
<li class="POD_ITEM"><a name="_1"></a>
<p class="POD_TEXT">
The method <code>$r-&gt;depth</code> returns the depth of <code>$r-&gt;node</code> 
in <code>$t</code>.
</p>
<li class="POD_ITEM"><a name="_2"></a>
<p class="POD_TEXT">
When called as a <code>Parse::Eyapp::Node</code> method, <code>$r-&gt;names</code>
returns the array of names of the transformations that matched.
</p>
</ul>
<p class="POD_TEXT">
The following example illustrates a use of <code>m</code> as 
a <code>Parse::Eyapp:YATW</code> method.
It solves a problem of scope analysis in a C compiler:
matching each <code>RETURN</code> statement with the function
that surrounds it. The treeregexp used is:
</p>
<pre class="POD_VERBATIM">
  retscope: /FUNCTION|RETURN/
</pre>
<p class="POD_TEXT">
and the code that solves the problem is:
</p>
<pre class="POD_VERBATIM">
 # Scope Analysis: Return-Function
 my @returns = $retscope-&gt;m($t); 
 for (@returns) {
   my $node = $_-&gt;node;
   if (ref($node) eq &#39;RETURN&#39;) {
     my $function = $_-&gt;father-&gt;node;
     $node-&gt;{function}  = $function;
     $node-&gt;{t} = $function-&gt;{t};
   }
 }
</pre>
<p class="POD_TEXT">
The first line gets a list of <code>Parse::Eyapp::Node::Match</code> nodes 
describing  the actual nodes that matched <code>/FUNCTION|RETURN/</code>. 
If the node described by <code>$_</code> is a <code>&#39;RETURN&#39;</code> node,
the expresion <code> $_-&gt;father-&gt;node</code> must necessarily point
to the function node that surrounds it.
</p>
<p class="POD_TEXT">
The second example shows the use of <code>m</code> as
a <code>Parse::Eyapp::Node</code> method.
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n m2.pl
  1  #!/usr/bin/perl -w
  2  use strict;
  3  use Rule6;
  4  use Parse::Eyapp::Treeregexp;
  5
  6  Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
  7    fold: /times|plus|div|minus/i:bin(NUM($n), NUM($m))
  8    zero_times_whatever: TIMES(NUM($x), .) and { $x-&gt;{attr} == 0 }
  9    whatever_times_zero: TIMES(., NUM($x)) and { $x-&gt;{attr} == 0 }
 10  })-&gt;generate();
 11
 12  # Syntax analysis
 13  my $parser = new Rule6();
 14  print &quot;Expression: &quot;; $parser-&gt;YYData-&gt;{INPUT} = &lt;&gt;;
 15  my $t = $parser-&gt;Run;
 16  local $Parse::Eyapp::Node::INDENT = 1;
 17  print &quot;Tree:&quot;,$t-&gt;str,&quot;\n&quot;;
 18
 19  # Search
 20  my $m = $t-&gt;m(our ($fold, $zero_times_whatever, $whatever_times_zero));
 21  print &quot;Match Node:&quot;,$m-&gt;str,&quot;\n&quot;;
</pre>
<p class="POD_TEXT">
When executed with input <code>0*0*0</code> the program generates this output:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; m2.pl
 Expression: 0*0*0
 Tree:
 TIMES(
   TIMES(
     NUM(
       TERMINAL
     ),
     NUM(
       TERMINAL
     )
   ),
   NUM(
     TERMINAL
   )
 )
 Match Node:
 Match[TIMES:0:whatever_times_zero](
   Match[TIMES:1:fold,zero_times_whatever,whatever_times_zero]
 )
</pre>
<p class="POD_TEXT">
The representation of <code>Match</code> nodes by <code>str</code> deserves a comment.
<code>Match</code> nodes have their own <code>info</code> method. It returns a string
containing the concatenation of the class of <code>$r-&gt;node</code> 
(i.e. the actual node that matched), the depth
(<code>$r-&gt;depth</code>) and the names of the transformations
that matched (as provided by the method <code>$r-&gt;names</code>)
</p>
<h3 class="POD_HEAD2"><a name="The_SEVERITY_option_">The <code>SEVERITY</code> option of <code>Parse::Eyapp::Treeregexp::new</code></a></h3>
<p class="POD_TEXT">
The <code>SEVERITY</code> option of <code>Parse::Eyapp::Treeregexp::new</code> controls the
way matching succeeds regarding the number of children.
To illustrate its use let us consider the following example.
The grammar <code>Rule6</code> used by the example is similar
to the one in the Synopsis example.
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n numchildren.pl
  1  #!/usr/bin/perl -w
  2  use strict;
  3  use Rule6;
  4  use Parse::Eyapp::Treeregexp;
  5  use Parse::Eyapp::Node;
  6
  7  sub TERMINAL::info { $_[0]{attr} }
  8
  9  my $severity = shift || 0;
 10  my $parser = new Rule6();
 11  $parser-&gt;YYData-&gt;{INPUT} = shift || &#39;0*2&#39;;
 12  my $t = $parser-&gt;Run;
 13
 14  my $transform = Parse::Eyapp::Treeregexp-&gt;new(
 15    STRING =&gt; q{
 16      zero_times_whatever: TIMES(NUM($x)) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
 17    },
 18    SEVERITY =&gt; $severity,
 19    FIRSTLINE =&gt; 15,
 20  )-&gt;generate;
 21
 22  $t-&gt;s(our @all);
 23
 24  print $t-&gt;str,&quot;\n&quot;;
</pre>
<p></p>
<p class="POD_TEXT">
The program gets the severity level from the command line (line 9).
The specification of the term <code>TIMES(NUM($x))</code> inside the
transformation <code>zero_times_whatever</code> does not
clearly state that <code>TIMES</code> must have two children.
There are several interpretations of the treregexp depending
on the level fixed for <code>SEVERITY</code>:
</p>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="0_TIMES_must_have_at"><p>0: <code>TIMES</code> must have at least one child. Don&#39;t care if it has more.</p></a>
<li class="POD_ITEM"><a name="1_TIMES_must_have_ex"><p>1: <code>TIMES</code> must have exactly one child.</p></a>
<li class="POD_ITEM"><a name="2_TIMES_must_have_ex"><p>2: <code>TIMES</code> must have exactly one child. When visit a 
<code>TIMES</code> node with a different number of children issue a warning.</p></a>
<li class="POD_ITEM"><a name="3_TIMES_must_have_ex"><p>3: <code>TIMES</code> must have exactly one child.  When visit a
<code>TIMES</code> node with a different number of children issue an
error.</p></a>
</ul>
<p class="POD_TEXT">
Observe the change in behavior according to the level of <code>SEVERITY</code>:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; numchildren.pl 0 &#39;0*2&#39;
 NUM(TERMINAL[0])
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; numchildren.pl 1 &#39;0*2&#39;
 TIMES(NUM(TERMINAL[0]),NUM(TERMINAL[2]))
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; numchildren.pl 2 &#39;0*2&#39;
 Warning! found node TIMES with 2 children.
 Expected 1 children (see line 16 of numchildren.pl)&quot;
 TIMES(NUM(TERMINAL[0]),NUM(TERMINAL[2]))
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; numchildren.pl 3 &#39;0*2&#39;
 Error! found node TIMES with 2 children.
 Expected 1 children (see line 16 of numchildren.pl)&quot;
  at (eval 2) line 29
</pre>
<h3 class="POD_HEAD2"><a name="Array_Treeregexp_Exp">Array Treeregexp Expressions</a></h3>
<p class="POD_TEXT">
The Treeregexp language permits expressions like:
</p>
<pre class="POD_VERBATIM">
                   A(@a,B($x),@c)
</pre>
<p class="POD_TEXT">
After the matching variable <code>@A</code> contains the shortest prefix
of <code>$A-&gt;children</code> that does not match <code>B($x)</code>.
The variable <code>@c</code> contains the remaining sufix of<br>&nbsp;<code>$A-&gt;children</code>.
</p>
<p class="POD_TEXT">
The following example uses 
array treereg expressions to move an assignment out
of loop (to be correct, we have to guarantee that
the assignment is an invariant of the loop). See
lines 98-111:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; \
       cat -n moveinvariantoutofloopcomplexformula.pl
   1  #!/usr/bin/perl -w
   2  use strict;
   3  use Parse::Eyapp;
   4  use Parse::Eyapp::Treeregexp;
   5
   6  my $grammar = q{
  ..      ............ # as usual, but including WHILE loops
  80  }; # end grammar
  ..  ......................................................................
  93  my $program = &quot;a =1000; c = 1; while (a) { c = c*a; b = 5; a = a-1 }\n&quot;;
  94  $parser-&gt;YYData-&gt;{INPUT} = $program;
  95  my $t = $parser-&gt;Run;
  96  my @output = split /\n/, $t-&gt;str;
  97
  98  my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
  99    moveinvariant: BLOCK(
 100                     @prests,
 101                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
 102                     @possts
 103                   )
 104      =&gt; {
 105           my $assign = $ASSIGN;
 106           $BLOCK[1]-&gt;delete($ASSIGN);
 107           $BLOCK[0]-&gt;insert_before($WHILE, $assign);
 108         }
 109    },
 110    FIRSTLINE =&gt; 99,
 111  );
 112  $p-&gt;generate();
 113  $moveinvariant-&gt;s($t);
 114  my @output2 = split /\n/, $t-&gt;str;
 115
 116  my ($node1, $node2);
 117  format STDOUT_TOP =
 118                          PROGRAM
 119  -------------------------------------------------------
 120  @||||||||||||||||||||||||||||||||||||||||||||||||||||||
 121  $program
 122  -------------------------------------------------------
 123  Before                     |    After
 124  ---------------------------|---------------------------
 125  .
 126
 127  format STDOUT =
 128  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;@|@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
 129  $node1,                    &#39;|&#39;,$node2
 130  .
 131
 132  for (1..$#output) {
 133    $node1 = $output[$_];
 134    $node2 = $output2[$_];
 135    write;
 136  }
</pre>
<p class="POD_TEXT">
The call to the method <code>delete</code> at line 106 deletes
the <code>ASSIGN</code> child of the second <code>BLOCK</code>.
The copy saved in <code>$assign</code> is inserted
as a child of the first block before
the loop.  Here is the output:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; \
       moveinvariantoutofloopcomplexformula.pl | cat -n
  1                          PROGRAM
  2  -------------------------------------------------------
  3   a =1000; c = 1; while (a) { c = c*a; b = 5; a = a-1 }
  4  -------------------------------------------------------
  5  Before                     |    After
  6  ---------------------------|---------------------------
  7  BLOCK(                     | BLOCK(
  8    ASSIGN(                  |   ASSIGN(
  9      TERMINAL[a],           |     TERMINAL[a],
 10      NUM(                   |     NUM(
 11        TERMINAL[1000]       |       TERMINAL[1000]
 12      )                      |     )
 13    ) # ASSIGN,              |   ) # ASSIGN,
 14    ASSIGN(                  |   ASSIGN(
 15      TERMINAL[c],           |     TERMINAL[c],
 16      NUM(                   |     NUM(
 17        TERMINAL[1]          |       TERMINAL[1]
 18      )                      |     )
 19    ) # ASSIGN,              |   ) # ASSIGN,
 20    WHILE(                   |   ASSIGN(
 21      VAR(                   |     TERMINAL[b],
 22        TERMINAL[a]          |     NUM(
 23      ),                     |       TERMINAL[5]
 24      BLOCK(                 |     )
 25        ASSIGN(              |   ) # ASSIGN,
 26          TERMINAL[c],       |   WHILE(
 27          TIMES(             |     VAR(
 28            VAR(             |       TERMINAL[a]
 29              TERMINAL[c]    |     ),
 30            ),               |     BLOCK(
 31            VAR(             |       ASSIGN(
 32              TERMINAL[a]    |         TERMINAL[c],
 33            )                |         TIMES(
 34          ) # TIMES          |           VAR(
 35        ) # ASSIGN,          |             TERMINAL[c]
 36        ASSIGN(              |           ),
 37          TERMINAL[b],       |           VAR(
 38          NUM(               |             TERMINAL[a]
 39            TERMINAL[5]      |           )
 40          )                  |         ) # TIMES
 41        ) # ASSIGN,          |       ) # ASSIGN,
 42        ASSIGN(              |       ASSIGN(
 43          TERMINAL[a],       |         TERMINAL[a],
 44          MINUS(             |         MINUS(
 45            VAR(             |           VAR(
 46              TERMINAL[a]    |             TERMINAL[a]
 47            ),               |           ),
 48            NUM(             |           NUM(
 49              TERMINAL[1]    |             TERMINAL[1]
 50            )                |           )
 51          ) # MINUS          |         ) # MINUS
 52        ) # ASSIGN           |       ) # ASSIGN
 53      ) # BLOCK              |     ) # BLOCK
 54    ) # WHILE                |   ) # WHILE
 55  ) # BLOCK                  | ) # BLOCK
</pre>
<p></p>
<h2 class="POD_HEAD1"><a name="Translation_Schemes">Translation Schemes</a></h2>
<p class="POD_TEXT">
Eyapp allows through the <code>%metatree</code> directive
the creation of <i>Translation Schemes</i> as described in the <a class="POD_LINK" href="#REFERENCES">Dragon&#39;s book</a>.
Instead of executing the semantic actions associated with the productions,
the syntax tree is built. Semantic actions aren&#39;t executed. Instead they are 
inserted as nodes of the syntax tree. The main difference with ordinary nodes
being that the attribute of such a <code>CODE</code> node is a reference to the anonymous 
subroutine representing the semantic action.
The tree is later traversed in depth-first order using the <code>$t-&gt;translation_scheme</code>
method: each time a <code>CODE</code> node
is visited  the action is executed.
</p>
<p class="POD_TEXT">
The following example parses a tiny subset of a typical
<i>typed language</i> and decorates the syntax tree with a new 
attribute <code>t</code> holding the type of each declared variable:
</p>
<pre class="POD_VERBATIM">
 use strict; # File examples/trans_scheme_simple_decls4.pl
 use Data::Dumper;
 use Parse::Eyapp;
 our %s; # symbol table

 my $ts = q{ 
   %token FLOAT INTEGER NAME

   %{
   our %s;
   %}

   %metatree

   %%
   Dl:  D &lt;* &#39;;&#39;&gt;
   ;

   D : $T { $L-&gt;{t} = $T-&gt;{t} } $L
   ;

   T : FLOAT    { $lhs-&gt;{t} = &quot;FLOAT&quot; }
     | INTEGER  { $lhs-&gt;{t} = &quot;INTEGER&quot; }
   ;

   L : $NAME
         { $NAME-&gt;{t} = $lhs-&gt;{t}; $s{$NAME-&gt;{attr}} = $NAME }
     | $NAME { $NAME-&gt;{t} = $lhs-&gt;{t}; $L-&gt;{t} = $lhs-&gt;{t} } &#39;,&#39; $L
         { $s{$NAME-&gt;{attr}} = $NAME }
   ;
   %%
 }; # end $ts

 sub Error { die &quot;Error sint&aacute;ctico\n&quot;; }

 { # Closure of $input, %reserved_words and $validchars
   my $input = &quot;&quot;;
   my %reserved_words = ();
   my $validchars = &quot;&quot;;

   sub parametrize__scanner {
     $input = shift;
     %reserved_words = %{shift()};
     $validchars = shift;
   }

   sub scanner {
     $input =~ m{\G\s+}gc;                     # skip whites
     if ($input =~ m{\G([a-z_A_Z]\w*)\b}gc) {
       my $w = uc($1);                 # upper case the word
       return ($w, $w) if exists $reserved_words{$w};
       return (&#39;NAME&#39;, $1);            # not a reserved word
     }
     return ($1, $1) if ($input =~ m/\G([$validchars])/gc);
     die &quot;Not valid token: $1\n&quot; if ($input =~ m/\G(\S)/gc);
     return (&#39;&#39;, undef); # end of file
   }
 } # end closure

 Parse::Eyapp-&gt;new_grammar(input=&gt;$ts,classname=&gt;&#39;main&#39;,outputfile=&gt;&#39;Types.pm&#39;);
 my $parser = main-&gt;new(yylex =&gt; \&amp;scanner, yyerror =&gt; \&amp;Error);

 parametrize__scanner(
   &quot;float x,y;\ninteger a,b\n&quot;,
   { INTEGER =&gt; &#39;INTEGER&#39;, FLOAT =&gt; &#39;FLOAT&#39;},
   &quot;,;&quot;
 );

 my $t = $parser-&gt;YYParse() or die &quot;Syntax Error analyzing input&quot;;

 $t-&gt;translation_scheme;

 $Data::Dumper::Indent = 1;
 $Data::Dumper::Terse = 1;
 $Data::Dumper::Deepcopy  = 1;
 $Data::Dumper::Deparse = 1;
 print Dumper($t);
 print Dumper(\%s);
</pre>
<p class="POD_TEXT">
Inside a Translation Scheme the lexical variable <code>$lhs</code> refers to the attribute
of the father.
</p>
<h3 class="POD_HEAD2"><a name="Execution_Stages_of_">Execution Stages of a Translation Scheme</a></h3>
<p class="POD_TEXT">
The execution of a Translation Scheme can be divided in the following stages:
</p>
<ol class="POD_LIST">
<li class="POD_ITEM"><a name="During"><p>During the first stage the grammar is analyzed and the parser is built:</p></a>
<pre class="POD_VERBATIM">
 Parse::Eyapp-&gt;new_grammar(input=&gt;$ts,classname=&gt;&#39;main&#39;,outputfile=&gt;&#39;Types.pm&#39;);
</pre>
<p class="POD_TEXT">
This stage is called <i>Class Construction Time</i>
</p>
<li class="POD_ITEM"><a name="A"><p>A parser conforming to the generated grammar is built</p></a>
<pre class="POD_VERBATIM">
  my $parser = main-&gt;new(yylex =&gt; \&amp;scanner, yyerror =&gt; \&amp;Error);
</pre>
<p class="POD_TEXT">
This stage is called  <i>Parser Construction Time</i>
</p>
<li class="POD_ITEM"><a name="The"><p>The next phase is <i>Tree construction time</i>. The input is set
and the tree is built:</p></a>
<pre class="POD_VERBATIM">
 parametrize__scanner(
    &quot;float x,y;\ninteger a,b\n&quot;,
    { INTEGER =&gt; &#39;INTEGER&#39;, FLOAT =&gt; &#39;FLOAT&#39;},
    &quot;,;&quot;
  );

  my $t = $parser-&gt;YYParse() or die &quot;Syntax Error analyzing input&quot;;
</pre>
<li class="POD_ITEM"><a name="The1"><p>The last stage is <i>Execution Time</i>. The tree is traversed in depth first
order and the <code>CODE</code> nodes are executed.</p></a>
<pre class="POD_VERBATIM">
                           $t-&gt;translation_scheme;
</pre>
</ol>
<p class="POD_TEXT">
This combination of bottom-up parsing with depth first traversin
leads to a semantic behavior similar to LL and top-down parsers
but with several differences:
</p>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="The_grammar_can_be_l"><p>The grammar can be left-recursive</p></a>
<li class="POD_ITEM"><a name="At_the_time_of_execu"><p>At the time of executing the action the syntax tree is already built, therefore we can refer
to nodes on the right side of the action like in:</p></a>
<pre class="POD_VERBATIM">
                      D : $T { $L-&gt;{t} = $T-&gt;{t} } $L
</pre>
</ul>
<h3 class="POD_HEAD2"><a name="The_begin_directive">The <code>%begin</code> directive</a></h3>
<p class="POD_TEXT">
The <code>%begin { code }</code> directive  can be used when
building a translation scheme, i.e. when under the 
control of the <code>%metatree</code> directive.
It indicates that such <code>code</code> will be executed at tree
construction time. Therefore the code receives as arguments
the references to the nodes of the branch than is being built.
Usually the code assist in the construction of the tree.
Line 39 of the following code shows an example.
The action <code>{ $exp }</code> simplifies the syntax tree
bypassing the parenthesis node. The example also illustrates
the combined use of default actions and 
translation schemes.
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; \
                cat -n trans_scheme_default_action.pl
   1  #!/usr/bin/perl -w
   2  use strict;
   3  use Data::Dumper;
   4  use Parse::Eyapp;
   5  use IO::Interactive qw(is_interactive);
   6
   7  my $translationscheme = q{
   8  %{
   9  # head code is available at tree construction time
  10  use Data::Dumper;
  11  our %sym; # symbol table
  12  %}
  13
  14  %defaultaction { $lhs-&gt;{n} = eval &quot; $left-&gt;{n} $_[2]-&gt;{attr} $right-&gt;{n} &quot; }
  15
  16  %metatree
  17
  18  %right   &#39;=&#39;
  19  %left   &#39;-&#39; &#39;+&#39;
  20  %left   &#39;*&#39; &#39;/&#39;
  21
  22  %%
  23  line:       %name EXP
  24                exp &lt;+ &#39;;&#39;&gt; /* Expressions separated by semicolons */
  25                  { $lhs-&gt;{n} = $_[1]-&gt;Last_child-&gt;{n} }
  26  ;
  27
  28  exp:
  29              %name PLUS
  30                exp.left &#39;+&#39; exp.right
  31          |   %name MINUS
  32                exp.left &#39;-&#39; exp.right
  33          |   %name TIMES
  34                exp.left &#39;*&#39; exp.right
  35          |   %name DIV
  36                exp.left &#39;/&#39; exp.right
  37          |   %name NUM   $NUM
  38                  { $lhs-&gt;{n} = $NUM-&gt;{attr} }
  39          |   &#39;(&#39; $exp &#39;)&#39;  %begin { $exp }
  40          |   %name VAR
  41                $VAR
  42                  { $lhs-&gt;{n} = $sym{$VAR-&gt;{attr}}-&gt;{n} }
  43          |   %name ASSIGN
  44                $VAR &#39;=&#39; $exp
  45                  { $lhs-&gt;{n} = $sym{$VAR-&gt;{attr}}-&gt;{n} = $exp-&gt;{n} }
  46
  47  ;
  48
  49  %%
  50  # tail code is available at tree construction time
  51  sub _Error {
  52    die &quot;Syntax error.\n&quot;;
  53  }
  54
  55  sub _Lexer {
  56      my($parser)=shift;
  57
  58      for ($parser-&gt;YYData-&gt;{INPUT}) {
  59          defined($_) or  return(&#39;&#39;,undef);
  60
  61          s/^\s*//;
  62          s/^([0-9]+(?:\.[0-9]+)?)// and return(&#39;NUM&#39;,$1);
  63          s/^([A-Za-z][A-Za-z0-9_]*)// and return(&#39;VAR&#39;,$1);
  64          s/^(.)// and return($1,$1);
  65          s/^\s*//;
  66      }
  67  }
  68
  69  sub Run {
  70      my($self)=shift;
  71      return $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error );
  72  }
  73  }; # end translation scheme
  74
  75  $Data::Dumper::Indent = 1;
  76  $Data::Dumper::Terse = 1;
  77  $Data::Dumper::Deepcopy  = 1;
  78  my $p = Parse::Eyapp-&gt;new_grammar(
  79    input=&gt;$translationscheme,
  80    classname=&gt;&#39;main&#39;,
  81    firstline =&gt; 6,
  82    outputfile =&gt; &#39;main.pm&#39;);
  83  die $p-&gt;qtables() if $p-&gt;Warnings;
  84  my $parser = main-&gt;new();
  85  print &quot;Write a sequence of arithmetic expressions: &quot; if is_interactive();
  86  $parser-&gt;YYData-&gt;{INPUT} = &lt;&gt;;
  87  my $t = $parser-&gt;Run() or die &quot;Syntax Error analyzing input&quot;;
  88  $t-&gt;translation_scheme;
  89  my $treestring = Dumper($t);
  90  our %sym;
  91  my $symboltable = Dumper(\%sym);
  92  print &lt;&lt;&quot;EOR&quot;;
  93  ***********Tree*************
  94  $treestring
  95  ******Symbol table**********
  96  $symboltable
  97  ************Result**********
  98  $t-&gt;{n}
  99
 100  EOR
</pre>
<h2 class="POD_HEAD1"><a name="Scope_Analysis_with_">Scope Analysis with <code>Parse::Eyapp::Scope</code></a></h2>
<p class="POD_TEXT">
<code>Parse::Eyapp</code> provides support for <i>Scope Analysis</i>
through the module <code>Parse::Eyapp::Scope</code>.
<i>Scope Analysis</i> solves the problem of <i>matching</i>
each instance or use of an object in the source text with
the definition that applies to such instance. Since it is
a <i>matching</i> problem it can sometimes easily solved 
using <code>m</code> as
it was explained in section <a class="POD_LINK" href="#Matching_Trees">Matching Trees</a>.
</p>
<p class="POD_TEXT">
The following pieces of code show how to implement scope
analysis for a C-like language using <code>Parse::Eyapp::Scope</code>
</p>
<pre class="POD_VERBATIM">
 nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple-Types/lib/Simple&gt; \
                           sed -n -e &#39;131,149p&#39; Types.eyp | cat -n
  1  sub reset_file_scope_vars {
  2    %st = (); # reset symbol table
  3    ($tokenbegin, $tokenend) = (1, 1);
  4    %type = ( INT  =&gt; Parse::Eyapp::Node-&gt;hnew(&#39;INT&#39;),  # like new but
  5              CHAR =&gt; Parse::Eyapp::Node-&gt;hnew(&#39;CHAR&#39;), # creates a DAG
  6              VOID =&gt; Parse::Eyapp::Node-&gt;hnew(&#39;VOID&#39;), 
  7            );
  8    $depth = 0;
  9    $ids = Parse::Eyapp::Scope-&gt;new(
 10             SCOPE_NAME =&gt; &#39;block&#39;,
 11             ENTRY_NAME =&gt; &#39;info&#39;,
 12             SCOPE_DEPTH =&gt; &#39;depth&#39;,
 13    );
 14    $loops = Parse::Eyapp::Scope-&gt;new(
 15             SCOPE_NAME =&gt; &#39;exits&#39;,
 16    );
 17    $ids-&gt;begin_scope();
 18    $loops-&gt;begin_scope(); 
 19  }
</pre>
<p></p>
<p class="POD_TEXT">
Of course you have to include a directive
</p>
<pre class="POD_VERBATIM">
                 use Parse::Eyapp::Scope
</pre>
<p class="POD_TEXT">
in your client program.
</p>
<p class="POD_TEXT">
The calls to <code>Parse::Eyapp::Scope-&gt;new</code> method (lines 9-13 and 14-16 in
the code above) create two <i>Scope Manager</i> objects. One 
scope manager to solve the
scope problem for variables (<code>$ids</code>) and another to solve
the scope problem for loops (<code>$loops</code>). The scope problem for
loops consists in matching each instance of a <code>BREAK</code> or <code>CONTINUE</code>
with the enclosing loop. The beginning of a
scope is set by calling to the <code>begin_scope</code> method
(lines 17 and 18). The end of a scope is signalled by a call to the
method <code>end_scope</code>. Of course, sub 
<code>reset_file_scope_vars</code> must be executed at the proper time:
</p>
<pre class="POD_VERBATIM">
 nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple-Types/lib/Simple&gt; \
                             sed -n -e &#39;170,203p&#39; Types.eyp | cat -n
  1  program: /* program -&gt; definition +  */
  2        {
  3          reset_file_scope_vars();
  4        }
  5      definition&lt;%name PROGRAM +&gt;.program
  6        {
  7          $program-&gt;{symboltable} = { %st };  # creates a copy of the s.t.
  8          $program-&gt;{depth} = 0;
  9          $program-&gt;{line}  = 1;
 10          $program-&gt;{types} = { %type };
 11          $program-&gt;{lines} = $tokenend;
 12
 13          my ($nondec, $declared) = $ids-&gt;end_scope($program-&gt;{symboltable}, $program, &#39;type&#39;);
 14
 15          # Type checking: add a direct pointer to the data-structure
 16          # describing the type
 17          $_-&gt;{t} = $type{$_-&gt;{type}} for @$declared;
 18
 19          if (@$nondec) {
 20            warn &quot;Identifier &quot;.$_-&gt;key.&quot; not declared at line &quot;.$_-&gt;line.&quot;\n&quot; for @$nondec;
 21            die &quot;\n&quot;;
 22          }
 23
 24          my $out_of_loops = $loops-&gt;end_scope($program);
 25          if (@$out_of_loops) {
 26            warn &quot;Error: &quot;.ref($_).&quot; outside of loop at line $_-&gt;{line}\n&quot; for @$out_of_loops;
 27            die &quot;\n&quot;;
 28          }
 29
 30          # Check that are not dangling breaks
 31          reset_file_scope_vars();
 32
 33          $program;
 34        }
</pre>
<p class="POD_TEXT">
Observe the different ways of calling <code>end_scope</code> (lines 13 and 24).
When a hash table is provided as first argument the declared symbols
will be automatically inserted in it. In such case the classes of the
nodes being inserted must have a <code>key</code> method that computes the key
for such node.
</p>
<pre class="POD_VERBATIM">
 nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple-Types/lib/Simple&gt; \
                            sed -n -e &#39;651,657p&#39; Types.eyp | cat -n
   1  sub VAR::key {
   2    my $self = shift;
   3
   4    return $self-&gt;child(0)-&gt;{attr}[0];
   5  }
   6
   7  *VARARRAY::key = *FUNCTIONCALL::key = \&amp;VAR::key;
</pre>
<p class="POD_TEXT">
Each instance of an <i>scoped object</i> must be declared as belonging
to the current scope using the <code>scope_instance</code> method. The following
is an example for the <code>$loops</code> scope manager object:
</p>
<pre class="POD_VERBATIM">
 nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple-Types/lib/Simple&gt; \
                            sed -n -e &#39;335,346p&#39; Types.eyp | cat -n
     1  statement:
     2      expression &#39;;&#39; { $_[1] }
     3    | &#39;;&#39;
     4    | %name BREAK
     5      $BREAK &#39;;&#39;
     6        {
     7          my $self = shift;
     8          my $node = $self-&gt;YYBuildAST(@_);
     9          $node-&gt;{line} = $BREAK-&gt;[1];
    10          $loops-&gt;scope_instance($node);
    11          return $node;
    12        }
</pre>
<p class="POD_TEXT">
and the following illustrates the same for the <code>$ids</code> scope manager:
</p>
<pre class="POD_VERBATIM">
 nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple-Types/lib/Simple&gt; \
                             sed -n -e &#39;410,425p&#39; Types.eyp | cat -n
     1  Primary:
     2      %name INUM
     3      INUM
     4    | %name CHARCONSTANT
     5      CHARCONSTANT
     6    | $Variable
     7        {
     8          $ids-&gt;scope_instance($Variable);
     9          return $Variable
    10        }
    11    | &#39;(&#39; expression &#39;)&#39; { $_[2] }
    12    | $function_call
    13        {
    14          $ids-&gt;scope_instance($function_call);
    15          return $function_call  # bypass
    16        }
</pre>
<p class="POD_TEXT">
Of course, in each place where a new scope begins/ends the corresponding
calls to <code>begin_scope</code> and <code>end_scope</code> must be issued. See the following
code:
</p>
<pre class="POD_VERBATIM">
 nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple-Types/lib/Simple&gt; \
                             sed -n -e &#39;277,302p&#39; Types.eyp | cat -n
   1  block:  /* Production is: block -&gt; &#39;{&#39; declaration * statement * &#39;}&#39; */
   2      &#39;{&#39;.bracket
   3         { $ids-&gt;begin_scope(); }
   4       declaration&lt;%name DECLARATIONS *&gt;.decs statement&lt;%name STATEMENTS *&gt;.sts &#39;}&#39;
   5         {
   6           my %st;
   7
   8           for my $lst ($decs-&gt;children) {
   9
  10               # control duplicated declarations
  11             my $message;
  12             die $message if $message = is_duplicated(\%st, $lst);
  13
  14             %st = (%st, %$lst);
  15           }
  16           $sts-&gt;{symboltable} = \%st;
  17           $sts-&gt;{line} = $bracket-&gt;[1];
  18           $sts-&gt;type(&quot;BLOCK&quot;) if (%st);
  19           my ($nondec, $dec) = $ids-&gt;end_scope(\%st, $sts, &#39;type&#39;);
  20
  21           # Type checking: add a direct pointer to the data-structure
  22           # describing the type
  23           $_-&gt;{t} = $type{$_-&gt;{type}} for @$dec;
  24
  25           return $sts;
  26         }
</pre>
<p></p>
<h2 class="POD_HEAD1"><a name="SEE_ALSO">SEE ALSO</a></h2>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="perldoc_Parse_Eyapp"><p>perldoc <u>Parse::Eyapp</u></p></a>
<li class="POD_ITEM"><a name="The_Eyapp_pdf_and_ey"><p>The <code>Eyapp.pdf</code> and  <code>eyapptut.pdf</code> files accompanying this distribution</p></a>
<li class="POD_ITEM"><a name="perldoc_eyapp_"><p>perldoc <a class="POD_LINK" href="eyapp.html">eyapp</a>,</p></a>
<li class="POD_ITEM"><a name="perldoc_treereg_"><p>perldoc <a class="POD_LINK" href="treereg.html">treereg</a>,</p></a>
<li class="POD_ITEM"><a name="An_lisis_L_xico_y_Si"><p><i>An&aacute;lisis L&eacute;xico y Sint&aacute;ctico</i>, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <a class="POD_LINK" href="http://nereida.deioc.ull.es/~pl/perlexamples/">http://nereida.deioc.ull.es/~pl/perlexamples/</a>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.</p></a>
<p></p>
<li class="POD_ITEM"><a name="Parse_Yapp_"><p><u>Parse::Yapp</u>,</p></a>
<li class="POD_ITEM"><a name="Man_pages_of_yacc_1_"><p>Man pages of yacc(1),</p></a>
<li class="POD_ITEM"><a name="Man_pages_of_bison_1"><p>Man pages of bison(1),</p></a>
<li class="POD_ITEM"><a name="Language_AttributeGr"><p><u>Language::AttributeGrammar</u></p></a>
<li class="POD_ITEM"><a name="Parse_RecDescent_"><p><u>Parse::RecDescent</u>.</p></a>
</ul>
<h2 class="POD_HEAD1"><a name="REFERENCES">REFERENCES</a></h2>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="The_classic_book_Com"><p>The classic book &quot;Compilers: Principles, Techniques, and Tools&quot; by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)</p></a>
</ul>
<h2 class="POD_HEAD1"><a name="AUTHOR">AUTHOR</a></h2>
<p class="POD_TEXT">
Casiano Rodriguez-Leon (casiano@ull.es)
</p>
<p class="POD_TEXT">
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
</p>
<h2 class="POD_HEAD1"><a name="ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h2>
<p class="POD_TEXT">
This work has been supported by CEE (FEDER) and the Spanish Ministry of
<i>Educaci&oacute;n y Ciencia</i> through Plan Nacional I+D+I number TIN2005-08818-C04-04
(ULL::OPLINK project <a class="POD_LINK" href="http://www.oplink.ull.es/">http://www.oplink.ull.es/</a>). 
Support from Gobierno de Canarias was through GC02210601
(Grupos Consolidados).
The University of La Laguna has also supported my work in many ways
and for many years.
</p>
<p class="POD_TEXT">
I wish to thank Francois Desarmenien for his <code>Parse::Yapp</code> module, 
to my students at La Laguna and to the Perl Community. Special thanks to 
my family and Larry Wall.
</p>
<h2 class="POD_HEAD1"><a name="LICENCE_AND_COPYRIGH">LICENCE AND COPYRIGHT</a></h2>
<p class="POD_TEXT">
Copyright (c) 2006-2007 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
</p>
<p class="POD_TEXT">
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998-2001
</p>
<p class="POD_TEXT">
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See <u>perlartistic</u>.
</p>
<p class="POD_TEXT">
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</p>
<hr>
<a class="POD_NAVLINK" href="#Pod_TOP_OF_PAGE">[Top]</a>
</body>
</html>

