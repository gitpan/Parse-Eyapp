# See: DynamicvsTieIns.eyp
# See: http://www.gnu.org/software/bison/manual/html_mono/bison.html#Lexical-Tie_002dins
# for a more detailed explanation.

%strict

%token ID INT INTEGER 
%syntactic token HEX

%right '='
%left '+'

%{
my %st;
%}

%tree bypass alias

%%
stmt:
    decl <* ';'> expr <%name EXPS + ';'>
      {
        $_[2]->{st} = { %st };
        $_[2];
      }
;

decl:
    INT ID <+ ','>
      {
        $st{$_->{attr}} = 1 for $_[2]->children();
      }
;

expr:
    %name ID
    ID
  | %name NUM
    INTEGER
  | %name HEX
    HEX '(' { $_[0]->{HEXFLAG} = 1; } $expr ')'
      { 
        $_[0]->{HEXFLAG} = 0; 
        $expr;
      }
  | %name ASSIGN
    $ID '=' expr 
      {
        my $parser = shift;
        my $t = $parser->YYBuildAST(@_);
        # Retype left (TERMINAL) child as ID
        $t->ID->type('ID');
        $t;
      }
  | %name PLUS
    expr '+' expr
;

%%

use Getopt::Long;
use List::Util qw{first};
use Data::Dumper;

sub _Error {
  my($token)=$_[0]->YYCurval;
  my($what)= $token ? "input: '$token'" : "end of input";
  my @expected = $_[0]->YYExpect();

  local $" = ', ';
  warn "Syntax error near $what. Expected one of these tokens: <@expected>\n";
  warn "Remaining input:\n". substr($_[0]->{input}, pos($_[0]->{input}));
  die # Dumper($_[0]->{STACK}[-1])
  ;
}


# Context-dependant lexer
sub lexer {
  my $parser = shift;
  my $hexflag = $parser->{HEXFLAG};

  for ($parser->{input}) {    # contextualize
    m{\G\s*(\#.*)?}gc;

    m{\G(HEX\b|INT\b)}igc and return (uc($1), $1);

    m{(\G\d+)}gc and return ('INTEGER', $hexflag? hex($1) : $1);


    m{\G([a-zA-Z_]\w*)}gc and do {
      my $match = $1;
      $hexflag and !exists($st{$match}) and $match =~ m{^([A-F0-9]+$)}gc and return ('INTEGER', hex($match)); 
      return ('ID', $1);
    };

    m{\G(.)}gc         and return ($1, $1);

    return('',undef);
  }
}

sub Run {
    my($self)=shift;
    my $yydebug = shift || 0;

    return $self->YYParse( 
      yylex => \&lexer, 
      yyerror => \&_Error,
      yydebug => $yydebug, # 0x1F
    );
}

sub uploadfile {
  my $file = shift;
  my $msg = shift;

  my $input = '';
  eval {
    $input = Parse::Eyapp::Base::slurp_file($file) 
  };
  if ($@) {
    print $msg;
    local $/ = undef;
    $input = <STDIN>;
  }
  return $input;
}

sub main {
  my $package = shift;

  my $debug = 0;
  my $file = '';
  my $result = GetOptions (
    "debug!" => \$debug,  
    "file=s" => \$file,
  );

  $debug = 0x1F if $debug;
  $file = shift if !$file && @ARGV; 

  my $parser = $package->new();
  my $prompt = "Expressions. Press CTRL-D (Unix) or CTRL-Z (Windows) to finish:\n";
  $parser->{input} = uploadfile($file, $prompt);
  print $parser->Run( $debug )->str,"\n";
}

*TERMINAL::info = *NUM::info = *ID::info = sub {
  $_[0]->{attr}
};

__PACKAGE__->main unless caller();

=head1 THE TYPENAME-IDENTIFIER PROBLEM WHEN PARSING THE C<C> LANGUAGE

The C language has a context dependency: the way an identifier is used depends
on what its current meaning is. For example, consider this:

  T(x);

This looks like a function call statement, but if C<T> is a typedef name, then
this is actually a declaration of C<x>. How can a parser for C decide how to
parse this input?

Here is another example:

  {
    T * x;
    ...
  }

What is this, a declaration of C<x> as a pointer to C<T>, 
or a void multiplication of the variables C<T> and C<x>?

The usual method to solve this problem is to have two different token types, C<ID> and C<TYPENAME>.
When the lexer finds an identifier, it looks up in the symbol table 
the current declaration of the identifier in order to 
decide which token type to return: C<TYPENAME> if the
identifier is declared as a typedef, C<ID> otherwise.

=head1 THIS EXAMPLE

One way to handle context-dependency is the lexical tie-in: a flag which is set
by the semantic actions, whose purpose is to alter the way tokens are parsed.

In this "Calc"-like example we have a language with a special construct C<hex
(hex-expr)>. After the keyword C<hex> comes an C<expression> in parentheses in
which all integers are hexadecimal. In particular, strings in C</[A-F0-9]+/>
like C<A1B> must be treated as an hex integer unless they were previously
declared.

Here the lexer looks at the value of the hexflag attribute; when it is nonzero,
all integers are parsed in hexadecimal, and tokens starting with letters are
parsed as integers if possible.

=head1 RUNNING

Compile it with C<-b>:

  ~/LEyapp/examples/debuggingtut$ eyapp -b '' SemanticInfoInTokens.eyp

and run it using option C<-file>:

  ~/LEyapp/examples/debuggingtut$ ./SemanticInfoInTokens.pm -file inputforsemanticinfo.txt
  EXPS(ASSIGN(ID[A],NUM[12]),ASSIGN(ID[B],NUM[177]),ASSIGN(ID[C],NUM[18]),ASSIGN(ID[B],PLUS(ID[A],ID[C])),ASSIGN(ID[B],PLUS(NUM[13],ID[C])))


You can also run it using option C<-debug>. Here the user typed the input:

  int A
  A = hex(A1+A)

here is the output:

  lusasoft@LusaSoft:~/LEyapp/examples/debuggingtut$ ./SemanticInfoInTokens.pm -debug
  Expressions. Press CTRL-D (Unix) or CTRL-Z (Windows) to finish:
  int A
  A = hex(A1+A)
  ----------------------------------------
  In state 0:
  Stack:[0]
  Need token. Got >INT<
  Shift and go to state 5.
  ----------------------------------------
  In state 5:
  Stack:[0,5]
  Need token. Got >ID<
  Shift and go to state 13.
  ----------------------------------------
  In state 13:
  Stack:[0,5,13]
  Don't need token.
  Reduce using rule 9 (PLUS-4 --> ID): Back to state 5, then go to state 14.
  ----------------------------------------
  In state 14:
  Stack:[0,5,14]
  Need token. Got >ID<
  Reduce using rule 10 (decl --> INT PLUS-4): Back to state 0, then go to state 3.
  ----------------------------------------
  In state 3:
  Stack:[0,3]
  Don't need token.
  Reduce using rule 2 (STAR-1 --> decl): Back to state 0, then go to state 4.
  ----------------------------------------
  In state 4:
  Stack:[0,4]
  Reduce using rule 3 (STAR-2 --> STAR-1): Back to state 0, then go to state 2.
  ----------------------------------------
  In state 2:
  Stack:[0,2]
  Shift and go to state 8.
  ----------------------------------------
  In state 8:
  Stack:[0,2,8]
  Need token. Got >=<
  Shift and go to state 15.
  ----------------------------------------
  In state 15:
  Stack:[0,2,8,15]
  Need token. Got >HEX<
  Shift and go to state 9.
  ----------------------------------------
  In state 9:
  Stack:[0,2,8,15,9]
  Need token. Got >(<
  Shift and go to state 16.
  ----------------------------------------
  In state 16:
  Stack:[0,2,8,15,9,16]
  Don't need token.
  Reduce using rule 14 (@13-2 --> /* empty */): Back to state 16, then go to state 22.
  ----------------------------------------
  In state 22:
  Stack:[0,2,8,15,9,16,22]
  Need token. Got >INTEGER<
  Shift and go to state 7.
  ----------------------------------------
  In state 7:
  Stack:[0,2,8,15,9,16,22,7]
  Don't need token.
  Reduce using rule 12 (expr --> INTEGER): Back to state 22, then go to state 26.
  ----------------------------------------
  In state 26:
  Stack:[0,2,8,15,9,16,22,26]
  Need token. Got >+<
  Shift and go to state 17.
  ----------------------------------------
  In state 17:
  Stack:[0,2,8,15,9,16,22,26,17]
  Need token. Got >ID<
  Shift and go to state 8.
  ----------------------------------------
  In state 8:
  Stack:[0,2,8,15,9,16,22,26,17,8]
  Need token. Got >)<
  Reduce using rule 11 (expr --> ID): Back to state 17, then go to state 23.
  ----------------------------------------
  In state 23:
  Stack:[0,2,8,15,9,16,22,26,17,23]
  Don't need token.
  Reduce using rule 16 (expr --> expr + expr): Back to state 22, then go to state 26.
  ----------------------------------------
  In state 26:
  Stack:[0,2,8,15,9,16,22,26]
  Shift and go to state 27.
  ----------------------------------------
  In state 27:
  Stack:[0,2,8,15,9,16,22,26,27]
  Don't need token.
  Reduce using rule 13 (expr --> HEX ( @13-2 expr )): Back to state 15, then go to state 21.
  ----------------------------------------
  In state 21:
  Stack:[0,2,8,15,21]
  Need token. Got ><
  Reduce using rule 15 (expr --> ID = expr): Back to state 2, then go to state 10.
  ----------------------------------------
  In state 10:
  Stack:[0,2,10]
  Reduce using rule 6 (PLUS-3 --> expr): Back to state 2, then go to state 11.
  ----------------------------------------
  In state 11:
  Stack:[0,2,11]
  Reduce using rule 7 (stmt --> STAR-2 PLUS-3): Back to state 0, then go to state 1.
  ----------------------------------------
  In state 1:
  Stack:[0,1]
  Shift and go to state 6.
  ----------------------------------------
  In state 6:
  Stack:[0,1,6]
  Don't need token.
  Accept.
  EXPS(ASSIGN(ID[A],PLUS(NUM[161],ID[A])))

=head1 SEE ALSO

=over 2

=item * L<http://www.gnu.org/software/bison/manual/html_mono/bison.html#Lexical-Tie_002dins>

=item * L<http://en.wikipedia.org/wiki/The_lexer_hack>

=item * L<http://eli.thegreenplace.net/2007/11/24/the-context-sensitivity-of-cs-grammar/>

=back
