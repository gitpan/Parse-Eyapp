# See section 'Hacking the Parsing Tables: ACTION and GOTOs'
# in http://search.cpan.org/perldoc?Parse::Eyapp::debuggingtut
#
# See also: Debug.eyp Debug1.eyp Debug2.eyp  LookForward.eyp
# DynamicallyChangingTheParser.eyp
# This example illustrates how to dynamically change the behavior of the parser

%token D S

%{
our $VERSION = '0.01';
my $input;
my ($conflictstate, $statetoshift);
%}

%tree bypass

%%
p:
    %name PROG
    ds ';' ss  
  | %name SS
    ss
;

ds:
    %name MORE_Ds
    D hacktables ';' ds    
  | %name LAST_D
    D hacktables        
      {
         # Recover former LALR action
         $_[0]->YYSetLRAction($conflictstate, ';', $statetoshift );
         # Do whatever you want
         goto &Parse::Eyapp::Driver::YYBuildAST;
      }
;

ss:
    %name SS
    S ';' ss      
  | %name S
    S       
;

hacktables:
    /* empty. Just for hacking the LALR tables */
      {
        my $self = shift;

        $conflictstate = $self->YYNextState();

        if ($input =~ m{^;\s*S}) {
          # Get current action
          $statetoshift = $self->YYGetLRAction($conflictstate, ';');
          $self->YYSetLRAction($conflictstate, ';', 'LAST_D' );
        }

        undef;
      }
;

%%

sub _Error {
  my $parser = shift;

  my ($token) = $parser->YYCurval;
  my ($what) = $token ? "input: '$token'" : "end of input";
  warn "Syntax error near $what\n";
}

sub _Lexer {
  my $self = shift;
  
  for ($input) {
    s{^(\s*)}{};
   
    return ('',undef) unless $_;

    return ($1,$1) if s/^(.)//;
  }
  return ('',undef);
}

sub Run {
  my $debug = shift || 0;
  $debug = 0x1F if $debug;

  $input = <STDIN>;

  my $self = __PACKAGE__->new();

  print 
    $self->YYParse( 
      yylex => \&_Lexer, 
      yyerror => \&_Error, 
      yydebug => $debug,
    )->str."\n";
}

sub TERMINAL::info {
  $_[0]->{attr};
}

Run(@ARGV) unless caller;
