  * labels and names %name in recycle. Fix it!
  * Article: rewrite, both research and divulgation
  * Documentation
     - Simpler intro
     - Separate parsing from tree transformation

  * bison compatible GLR directive: %expect-rr 1
  * the #line directive in Parse.yp for %lexer is buggy (worst practice)

  * Lexical Analyzer generation:
      * Lexer automatic construction
      * lexer must support a sub name
         %lexer mylexer

  * Dynamic conflict resolution: test YYSetShift
        The case where the default is a reduction is not solved. Investigate

  * C interface with YAML

  * Lars request (see dir contributions): allow AST classes to be Moose or any other OOP framework

  * Provide debugging support for standalone modules: currently skipped

  * Provide an argument named 
                                'end_of_input' => [ token list: '', NUM, etc. ]

    to be used in YYParse. When an error is found, if the token is in the set 'end_of_input' the input
    will be accepted if in the accepting state

  * There is a bug in eyapp with reduce-reduce conflicts?! I am not sure of this
    with reduce-reduce conflicts. In at least one case is reducing by the second production rule instead 
    of the first.  It appears in the C++ parser (t/99Cplusplusgrammar.t). Confirm

  * Add tests to check .output tables: actions and gotos against yacc. 
    I am not confident that some modifications I introduced in Grammar.pm were error free

  * There is a bug with &give_rhs_name in Parse::Eyapp::Grammar and lists *, +, etc. see the example
      examples/debuggintut/SemanticInfoInTokens.eyp

    Not always a syntactic variable is a valid identifier: e.g. PLUS-1
    Probably, it is better that the method "tokennames" give names to the syntactic variables

  * str method to produce GraphViz, latex and/or other formats

  * Treereg EXPORT and EXPORT_OK

  * Language generation example examples/generator
     -- Return a Test::LectroTest::Generator? 

  * Automatic naming scheme: tests!

  * Check that all the production names (given with %name directives) are different. May be not

  * Combine Flex and eyapp

  * Grammar reuse, grammars as subroutines/methods: a grammar subroutine for variable B 
    is implemented via 

             B -> FIRST(B) { CALL PARSER FOR B}

     The sublanguage is a set of tokens from the superlanguage perspective. The token attribute is the value
     returned by the parser. The lexer must be changed to finish when a FOLLOW(B) is found. Line number
     and input require special consideration

  *  Introduce the directive %input FILE. We need to control line numbers and file names for this.
     May be we need a full preprocessor for this

  * When using option %delegateaction we must check that the client must have 
  methods with names the names of the production rules (see example in the Simon's book
  Advanced programming for this). In fact is a case of "abstract method"

  * There is a generic 'Error' routine: provide it

  * Not sure: eyappoption -t will generate a 'tag' file

  * target 'version' in Makefile.PL: make a vim script

  * PUBLIC_PLACE implies to copy to a remote machine (nereida)

  * Implement the directive
       %package Math::Calc 
    (like the option -m of eyapp)

  * common examples generated through the text template. Idem MANIFEST

  * Lexical analyzer seems to be in a mess: line count seem full of bugs

  * delete_method isn't documented
  * Document generate, new, etc. in treeregexp
  * Add to Parse::Eyapp::Base function
             MakeHierarchy('BinaryOp(PLUS, TIMES, MINUS, DIV) Operation(BinaryOp)')
    that will build a inheritance hierarchy

  * Unify: to support trees and not only dags a symbol table will be helpful
  * Parse::Eyapp::Node->new: Probably s.t. like
     TUTU(TITI({ $[0]->{chu} = 4 }) {$_[0]->{k} = "hello"})
    will be better to initialize the attributes

  * Document Parse::Eyapp::Base
- Distribution
  * Attributed Grammars
  * ABSTRACT 
  * Output files .pm generated by the tests. Don't
  * numchildren method
  * token definitions %token NUM = qr{\d+}
    It can be used later in the lexer as
           return ('NUM', $1) if m{($NUM)};
    That is the $NUM variable will be declared. Scope?
 
  ***** Reorganize the translation of Treeregexp: the code in the "and" and =>
    clauses will be a method of the classes of the nodes matching the treeregexp
    - $treereg->classes computes the classes. doing nothing yet
    - @{$methods{$_}} contain the classes
    - Methods Parse::Eyapp::Treeregexp::REGEXP_INNER::classes included
    - Factorize

  * star treeregexp will be supressed *
  * Introduce DECLARATION* in treeregexes
  * "previous" clause for YATW objects when using "bud". The YATW will 
    be executed before visiting the children. An example of the advantage
    of doing this is to use "bud" for scope analysis
  * %default action must have an scope
  * Factorize YYBuildAST and YYActionforT_TX1X2 etc.
    There is a problem with TERMINAL::save_attributes ?
    bypass, plus and star lists, etc. There is no coherent interface
    at the moment
  * version numbers
  * Warning diagnostic (Yure): ID and 'ID' is prone to error
    Non defined variables are considered terminals: see Identifyattr2.yp. Put info in Output
  * Better diagnostics: see -v 
  * Redesign eyapp program structure for documentation (pods): head body legs tail 
    (or __END__ ?)
  * .output in HTML (?)
  * Some data structures inside the Parser object are only required 
    if the %tree or %metatree directives are active. Otimize them away
    when they are not used (for example syntax tokens, bypass, etc.).
  * Change names of _PLUSLIST, etc. Make a directive to name them 
       %name * => _STAR  + => ... , etc.
    It may influence optimizations like the PARENTHESIS one?
  * bypass method for YATW and Node objects

  * test for yyfilename
  * Fix the yyprefix consistency problem between new and YYParse (args)
  * What is YYFilename in Driver.pm

  * Reference manual. Document functions and methods
    -- Sort by alphabetical order
    -- User methods and subroutines. Internal documentation

- Treereg Tree grammars and tree walkers
 
  * Tests
     - Some rules can be optimized away. Then the name dissapears!!
     - When a token is in uppercase then it does not agree with the string?
     - tests with syntax errors
     - Standalone works?
     - Debug mode works?

  * Uniformize 
     - Lower case in new_grammar, uppercase in Treeregexp new, etc.
     - Also look at scripts

  * Private methods
  * Indentation and line numbers. 

- Translation Schemes
  * Scheme examples: leftrec, etc.
  * Tests
    - In TS delete the code refs using treeregexp
  * Documentation
  * Executable transscheme
  * Delete args in YATW objects it seems they are no use
  * TERMINAL nodes inherit from TS and Node. What if I have two parsers
    in the same application?
  * Put option %yaml file when using a translation scheme to save the AST

  * TS: Don't check syntax during the construction phase?
  * Check syntax option in eyapp
  * Keep Line Numbers in the tree (for tokens)

  * Factorize lists code
  * Admitir directivas-especificaciones de si la lista debe ser left-recursive o right-recursive
  * Esquema de nombres de las reglas temporales:
      Reservar la numeración de las reglas de la gramática original
      y usar posiciones adicionales para las reglas temporales.
  * Hacer una directiva para la generacion de reglas de error en listas
  
  * Supress when production code use Data::Dumper;
  
  * %packagename %outputfile %numbers, etc.
  
- Optimizations:
  * Driver in C
  * BuildAST in C


************ PROJECTS *********************
* Human friendly warnings and errors, conflicts, debugger with breaks, etc.

