Cannot find page `Parse::Eyapp::eyapptut' at L<> on line 226
Cannot find page `Parse::Yapp' at L<> on line 766
Cannot find page `yapp' at L<> on line 989
Cannot find page `List::MoreUtils' at L<> on line 2200
Cannot find page `List::Util' at L<> on line 2202
Cannot find page `Data::Dumper' at L<> on line 2204
Cannot find page `Pod::Usage' at L<> on line 2206
Cannot find page `List::Util' at L<> on line 2210
Cannot find page `Data::Dumper' at L<> on line 2216
Cannot find page `Pod::Usage' at L<> on line 2221
Cannot find page `Test::Pod' at L<> on line 2234
Cannot find page `Test::Warn' at L<> on line 2236
Cannot find page `Test::Exception' at L<> on line 2238
Cannot find page `Test::Warn' at L<> on line 2242
Cannot find page `Test::Pod' at L<> on line 2242
Cannot find page `Test::Exception' at L<> on line 2242
Cannot find page `Parse::Yapp' at L<> on line 2285
Cannot find page `Parse::eyapptut' at L<> on line 2337
Cannot find page `Parse::Yapp' at L<> on line 2353
Cannot find page `Language::AttributeGrammar' at L<> on line 2362
Cannot find page `Parse::RecDescent' at L<> on line 2365
Cannot find page `perlartistic' at L<> on line 2408
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<meta content="text/css" http-equiv="Content-Style-Type">
<meta content="Marek::Pod::HTML 0.49" name="GENERATOR">
<title>Eyapp</title>
</head>
<body>
<a class="POD_NAVLINK" name="Pod_TOP_OF_PAGE"></a>
<h1 class="POD_TITLE">Eyapp</h1>
<hr>
<ul>
<li><a class="POD_NAVLINK" href="#NAME">NAME</a>
<li><a class="POD_NAVLINK" href="#VERSION">VERSION</a>
<li><a class="POD_NAVLINK" href="#SYNOPSIS">SYNOPSIS</a>
<li><a class="POD_NAVLINK" href="#Introduction">Introduction</a>
<li><a class="POD_NAVLINK" href="#The_Eyapp_Language">The Eyapp Language</a>
<li><a class="POD_NAVLINK" href="#The_Treeregexp_Langu">The Treeregexp Language</a>
<ul>
<li><a class="POD_NAVLINK" href="#Treeregexp_rules">Treeregexp rules</a>
<ul>
<li><a class="POD_NAVLINK" href="#The_treeregexp">The treeregexp</a>
<li><a class="POD_NAVLINK" href="#Semantic_condition">Semantic condition</a>
<li><a class="POD_NAVLINK" href="#Referencing_the_matc">Referencing the matching nodes</a>
<li><a class="POD_NAVLINK" href="#Transformation_code">Transformation code</a>
</ul>
<li><a class="POD_NAVLINK" href="#Regexp_Treeregexes">Regexp Treeregexes</a>
<li><a class="POD_NAVLINK" href="#Scalar_Treeregexes">Scalar Treeregexes</a>
<li><a class="POD_NAVLINK" href="#Dot_Treeregexes">Dot Treeregexes</a>
<li><a class="POD_NAVLINK" href="#Array_Treeregexp_Exp">Array Treeregexp Expressions</a>
<li><a class="POD_NAVLINK" href="#Star_Treeregexp">Star Treeregexp</a>
<li><a class="POD_NAVLINK" href="#Transformation_Famil">Transformation Families</a>
<li><a class="POD_NAVLINK" href="#Code_Support">Code Support</a>
</ul>
<li><a class="POD_NAVLINK" href="#Parse_Eyapp_Methods"><code>Parse::Eyapp</code> Methods</a>
<ul>
<li><a class="POD_NAVLINK" href="#Parse_Eyapp_new_gram">Parse::Eyapp-&gt;new_grammar</a>
<li><a class="POD_NAVLINK" href="#_eyapp_qtables">$eyapp-&gt;qtables</a>
<li><a class="POD_NAVLINK" href="#_eyapp_outputtables">$eyapp-&gt;outputtables</a>
<li><a class="POD_NAVLINK" href="#_eyapp_Warnings">$eyapp-&gt;Warnings</a>
<li><a class="POD_NAVLINK" href="#_eyapp_ShowDfa">$eyapp-&gt;ShowDfa</a>
<li><a class="POD_NAVLINK" href="#_eyapp_Summary">$eyapp-&gt;Summary</a>
<li><a class="POD_NAVLINK" href="#_eyapp_Conflicts">$eyapp-&gt;Conflicts</a>
<li><a class="POD_NAVLINK" href="#_eyapp_DfaTable">$eyapp-&gt;DfaTable</a>
</ul>
<li><a class="POD_NAVLINK" href="#Methods_Available_in">Methods Available in the Generated <code>Class</code></a>
<ul>
<li><a class="POD_NAVLINK" href="#Class_new">Class-&gt;new</a>
<li><a class="POD_NAVLINK" href="#_parser_YYParse_">$parser-&gt;YYParse()</a>
<li><a class="POD_NAVLINK" href="#_parser_YYErrok">$parser-&gt;YYErrok</a>
<li><a class="POD_NAVLINK" href="#_parser_YYError">$parser-&gt;YYError</a>
<li><a class="POD_NAVLINK" href="#_parser_YYNberr">$parser-&gt;YYNberr</a>
<li><a class="POD_NAVLINK" href="#_parser_YYAccept">$parser-&gt;YYAccept</a>
<li><a class="POD_NAVLINK" href="#_parser_YYAbort">$parser-&gt;YYAbort</a>
<li><a class="POD_NAVLINK" href="#_parser_YYRecovering">$parser-&gt;YYRecovering</a>
<li><a class="POD_NAVLINK" href="#_parser_YYCurtok">$parser-&gt;YYCurtok</a>
<li><a class="POD_NAVLINK" href="#_parser_YYCurval">$parser-&gt;YYCurval</a>
<li><a class="POD_NAVLINK" href="#_parser_YYExpect">$parser-&gt;YYExpect</a>
<li><a class="POD_NAVLINK" href="#_parser_YYLexer">$parser-&gt;YYLexer</a>
<li><a class="POD_NAVLINK" href="#_parser_YYLhs">$parser-&gt;YYLhs</a>
<li><a class="POD_NAVLINK" href="#_parser_YYRuleindex">$parser-&gt;YYRuleindex</a>
<li><a class="POD_NAVLINK" href="#_parser_YYRightside">$parser-&gt;YYRightside</a>
<li><a class="POD_NAVLINK" href="#_parser_YYIsterm">$parser-&gt;YYIsterm</a>
<li><a class="POD_NAVLINK" href="#_parser_YYIssemantic">$parser-&gt;YYIssemantic</a>
<li><a class="POD_NAVLINK" href="#_parser_YYName">$parser-&gt;YYName</a>
<li><a class="POD_NAVLINK" href="#_parser_YYPrefix">$parser-&gt;YYPrefix</a>
<li><a class="POD_NAVLINK" href="#_parser_YYBypass">$parser-&gt;YYBypass</a>
<li><a class="POD_NAVLINK" href="#_parser_YYBypassrule">$parser-&gt;YYBypassrule</a>
<li><a class="POD_NAVLINK" href="#_parser_YYFirstline">$parser-&gt;YYFirstline</a>
<li><a class="POD_NAVLINK" href="#_parser_BeANode">$parser-&gt;BeANode</a>
<li><a class="POD_NAVLINK" href="#_parser_YYBuildAST">$parser-&gt;YYBuildAST</a>
<li><a class="POD_NAVLINK" href="#_parser_YYBuildTS">$parser-&gt;YYBuildTS</a>
</ul>
<li><a class="POD_NAVLINK" href="#Parse_Eyapp_Parse_ob"><code>Parse::Eyapp::Parse</code> objects</a>
<li><a class="POD_NAVLINK" href="#Parse_Eyapp_Node_Met">Parse::Eyapp::Node Methods</a>
<ul>
<li><a class="POD_NAVLINK" href="#Parse_Eyapp_Node_new">Parse::Eyapp::Node-&gt;new</a>
<li><a class="POD_NAVLINK" href="#Parse_Eyapp_Node_hne"><code>Parse::Eyapp::Node-&gt;hnew</code></a>
<li><a class="POD_NAVLINK" href="#_node_type">$node-&gt;type</a>
<li><a class="POD_NAVLINK" href="#_node_child">$node-&gt;child</a>
<li><a class="POD_NAVLINK" href="#Child_Access_Through">Child Access Through <code>%tree alias</code></a>
<li><a class="POD_NAVLINK" href="#_node_children">$node-&gt;children</a>
<li><a class="POD_NAVLINK" href="#_node_Children">$node-&gt;Children</a>
<li><a class="POD_NAVLINK" href="#_node_last_child">$node-&gt;last_child</a>
<li><a class="POD_NAVLINK" href="#_node_Last_child">$node-&gt;Last_child</a>
<li><a class="POD_NAVLINK" href="#_node_descendant">$node-&gt;descendant</a>
<li><a class="POD_NAVLINK" href="#_node_str">$node-&gt;str</a>
<li><a class="POD_NAVLINK" href="#_node_delete_child_">$node-&gt;delete($child)</a>
<li><a class="POD_NAVLINK" href="#_node_unshift_newchi">$node-&gt;unshift($newchild)</a>
<li><a class="POD_NAVLINK" href="#_node_push_newchild_">$node-&gt;push($newchild)</a>
<li><a class="POD_NAVLINK" href="#_node_insert_before_">$node-&gt;insert_before($position, $new_child)</a>
<li><a class="POD_NAVLINK" href="#_node_insert_after_p">$node-&gt;insert_after($position, $new_child)</a>
<li><a class="POD_NAVLINK" href="#_node_translation_sc">$node-&gt;translation_scheme</a>
<li><a class="POD_NAVLINK" href="#_node_bud">$node-&gt;bud</a>
</ul>
<li><a class="POD_NAVLINK" href="#TRANSFORMATIONS_Pars">TRANSFORMATIONS: Parse::Eyapp:YATW</a>
<ul>
<li><a class="POD_NAVLINK" href="#Parse_Eyapp_Node_new1">Parse::Eyapp::Node-&gt;new</a>
<li><a class="POD_NAVLINK" href="#The_YATW_Tree_Transf">The YATW Tree Transformation Call Protocol</a>
<li><a class="POD_NAVLINK" href="#Parse_Eyapp_YATW_bui">Parse::Eyapp::YATW-&gt;buildpatterns</a>
<li><a class="POD_NAVLINK" href="#_yatw_delete">$yatw-&gt;delete</a>
<li><a class="POD_NAVLINK" href="#_yatw_unshift_b_">$yatw-&gt;unshift($b)</a>
<li><a class="POD_NAVLINK" href="#_yatw_insert_before_">$yatw-&gt;insert_before($node)</a>
</ul>
<li><a class="POD_NAVLINK" href="#Matching_Trees">Matching Trees</a>
<ul>
<li><a class="POD_NAVLINK" href="#The_SEVERITY_option_">The <code>SEVERITY</code> option of <code>Parse::Eyapp::Treeregexp::new</code></a>
</ul>
<li><a class="POD_NAVLINK" href="#Tree_Substitution_Th">Tree Substitution: The <code>s</code> methods</a>
<li><a class="POD_NAVLINK" href="#Parse_Eyapp_Scope">Parse::Eyapp::Scope</a>
<ul>
<li><a class="POD_NAVLINK" href="#_scope_end_scope">$scope-&gt;end_scope</a>
<ul>
<li><a class="POD_NAVLINK" href="#_scope_end_scope_wit">$scope-&gt;end_scope with first Arg a Symbol Table</a>
<li><a class="POD_NAVLINK" href="#_scope_end_scope_for">$scope-&gt;end_scope for Simple Scope Analysis</a>
</ul>
<li><a class="POD_NAVLINK" href="#_scope_begin_scope">$scope-&gt;begin_scope</a>
<li><a class="POD_NAVLINK" href="#_scope_scope_instanc">$scope-&gt;scope_instance</a>
<li><a class="POD_NAVLINK" href="#Parse_Eyapp_Scope_ne">Parse::Eyapp::Scope-&gt;new</a>
</ul>
<li><a class="POD_NAVLINK" href="#ENVIRONMENT">ENVIRONMENT</a>
<li><a class="POD_NAVLINK" href="#DEPENDENCIES">DEPENDENCIES</a>
<li><a class="POD_NAVLINK" href="#INSTALLATION">INSTALLATION</a>
<li><a class="POD_NAVLINK" href="#BUGS_AND_LIMITATIONS">BUGS AND LIMITATIONS</a>
<li><a class="POD_NAVLINK" href="#SEE_ALSO">SEE ALSO</a>
<li><a class="POD_NAVLINK" href="#REFERENCES">REFERENCES</a>
<li><a class="POD_NAVLINK" href="#AUTHOR">AUTHOR</a>
<li><a class="POD_NAVLINK" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a>
<li><a class="POD_NAVLINK" href="#LICENCE_AND_COPYRIGH">LICENCE AND COPYRIGHT</a>
</ul>
<hr>
<h2 class="POD_HEAD1"><a name="NAME">NAME</a></h2>
<p class="POD_TEXT">
Parse::Eyapp
</p>
<p></p>
<h2 class="POD_HEAD1"><a name="VERSION">VERSION</a></h2>
<p class="POD_TEXT">
1.06503
</p>
<h2 class="POD_HEAD1"><a name="SYNOPSIS">SYNOPSIS</a></h2>
<pre class="POD_VERBATIM">
 use strict;
 use Parse::Eyapp;
 use Parse::Eyapp::Treeregexp;

 sub TERMINAL::info {
   $_[0]{attr}
 }

 my $grammar = q{
   %right  &#39;=&#39;     # Lowest precedence
   %left   &#39;-&#39; &#39;+&#39; # + and - have more precedence than = Disambiguate a-b-c as (a-b)-c
   %left   &#39;*&#39; &#39;/&#39; # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
   %left   NEG     # Disambiguate -a-b as (-a)-b and not as -(a-b)
   %tree           # Let us build an abstract syntax tree ...

   %%
   line: exp &lt;%name EXPRESION_LIST + &#39;;&#39;&gt;  { $_[1] } /* list of expressions separated by &#39;;&#39; */
   ;

   /* The %name directive defines the name of the class to which the node being built belongs */
   exp:
       %name NUM  NUM            | %name VAR   VAR         | %name ASSIGN VAR &#39;=&#39; exp
     | %name PLUS exp &#39;+&#39; exp    | %name MINUS exp &#39;-&#39; exp | %name TIMES  exp &#39;*&#39; exp
     | %name DIV     exp &#39;/&#39; exp | %name UMINUS &#39;-&#39; exp %prec NEG
     |   &#39;(&#39; exp &#39;)&#39;  { $_[2] }  /* Let us simplify a bit the tree */
   ;

   %%
   sub _Error { die &quot;Syntax error near &quot;.($_[0]-&gt;YYCurval?$_[0]-&gt;YYCurval:&quot;end of file&quot;).&quot;\n&quot; }

   sub _Lexer {
     my($parser)=shift; # The parser object

     for ($parser-&gt;YYData-&gt;{INPUT}) {
       s/^\s+//;
       $_ eq &#39;&#39; and return(&#39;&#39;,undef);
       s/^([0-9]+(?:\.[0-9]+)?)// and return(&#39;NUM&#39;,$1);
       s/^([A-Za-z][A-Za-z0-9_]*)// and return(&#39;VAR&#39;,$1);
       s/^(.)//s and return($1,$1);
     }
   }

   sub Run {
       my($self)=shift;
       $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error, );
   }
 }; # end grammar

 our (@all, $uminus);

 Parse::Eyapp-&gt;new_grammar( # Create the parser package/class
   input=&gt;$grammar,
   classname=&gt;&#39;Calc&#39;, # The name of the package containing the parser
   firstline=&gt;7       # String $grammar starts at line 7 (for error diagnostics)
 );
 my $parser = Calc-&gt;new();                # Create a parser
 $parser-&gt;YYData-&gt;{INPUT} = &quot;2*-3+b*0;--2\n&quot;; # Set the input
 my $t = $parser-&gt;Run;                    # Parse it!
 local $Parse::Eyapp::Node::INDENT=2;
 print &quot;Syntax Tree:&quot;,$t-&gt;str;

 # Let us transform the tree. Define the tree-regular expressions ..
 my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
   { #  Example of support code
     my %Op = (PLUS=&gt;&#39;+&#39;, MINUS =&gt; &#39;-&#39;, TIMES=&gt;&#39;*&#39;, DIV =&gt; &#39;/&#39;);
   }
   constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($x), NUM($y))
     =&gt; {
       my $op = $Op{ref($_[0])};
       $x-&gt;{attr} = eval  &quot;$x-&gt;{attr} $op $y-&gt;{attr}&quot;;
       $_[0] = $NUM[0];
     }
   uminus: UMINUS(NUM($x)) =&gt; { $x-&gt;{attr} = -$x-&gt;{attr}; $_[0] = $NUM }
   zero_times_whatever: TIMES(NUM($x), .) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
   whatever_times_zero: TIMES(., NUM($x)) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
   },
   OUTPUTFILE=&gt; &#39;main.pm&#39;
 );
 $p-&gt;generate(); # Create the tranformations

 $t-&gt;s($uminus); # Transform UMINUS nodes
 $t-&gt;s(@all);    # constant folding and mult. by zero

 local $Parse::Eyapp::Node::INDENT=0;
 print &quot;\nSyntax Tree after transformations:\n&quot;,$t-&gt;str,&quot;\n&quot;;
</pre>
<p></p>
<h2 class="POD_HEAD1"><a name="Introduction">Introduction</a></h2>
<p class="POD_TEXT">
Parse::Eyapp (Extended yapp) is a collection of modules
that extends Francois Desarmenien Parse::Yapp 1.05.
Eyapp extends yacc/yapp syntax with 
functionalities line named attributes,
EBNF-like expressiones, modifiable default action,
automatic syntax tree building,
semi-automatic abstract syntax tree building,
translation schemes, tree regular expressions,
tree transformations, scope analysis, support,
directed acyclic graphs and a few more.
</p>
<p class="POD_TEXT">
<i>This is a reference manual</i>. 
<i>To read an introduction to</i> 
<code>Parse::Eyapp</code> <i>see</i> <code>Parse::eyapptut</code>.
</p>
<h2 class="POD_HEAD1"><a name="The_Eyapp_Language">The Eyapp Language</a></h2>
<p class="POD_TEXT">
In Eyapp the <code>+</code> operator indicates one or more repetitions of the element
to the left of <code>+</code>, thus the rule:
</p>
<pre class="POD_VERBATIM">
                        decls:  decl +
</pre>
<p class="POD_TEXT">
is the same as:
</p>
<pre class="POD_VERBATIM">
                        decls:  decls decl 
                             |  decl
</pre>
<p class="POD_TEXT">
An additional  symbol may be included  to indicate lists of elements 
separated by such symbol. Thus
</p>
<pre class="POD_VERBATIM">
                       rhss: rule &lt;+ &#39;|&#39;&gt;
</pre>
<p class="POD_TEXT">
is equivalent to:
</p>
<pre class="POD_VERBATIM">
                       rhss: rhss &#39;|&#39; rule 
                           | rule
</pre>
<p class="POD_TEXT">
The operators <code>*</code> and <code>?</code> have their usual meaning: 0 or more for
<code>*</code> and optionality for <code>?</code>. Is legal to parenthesize 
a <code>rhs</code> expression as in:
</p>
<pre class="POD_VERBATIM">
                       optname: (NAME IDENT)?
</pre>
<p class="POD_TEXT">
Follows the grammar accepted by <code>eyapp</code> using its own notation.
Semicolons have been omitted to save space.
Between C-like comments you can find an (informal) 
explanation of the language 
associated with the token.
</p>
<p></p>
<pre class="POD_VERBATIM">
  eyapp: head body tail ;
  symbol: LITERAL  /* A string literal like &#39;hello&#39; */
      |   ident   
  ident:  IDENT  /* IDENT is [A-Za-z_][A-Za-z0-9_]* */ 
  head: headsec &#39;%%&#39;
  headsec:  decls ? 
  decls:  decl +
  decl:  &#39;\n&#39;      
      |   SEMANTIC typedecl symlist &#39;\n&#39;  /* SEMANTIC  is %semantic\s+token      */
      |   SYNTACTIC typedecl symlist &#39;\n&#39; /* SYNTACTIC is %syntactic\s+token     */
      |   TOKEN typedecl symlist &#39;\n&#39;     /* TOKEN     is %token                 */
      |   ASSOC typedecl symlist &#39;\n&#39;     /* ASSOC     is %(left|right|nonassoc) */
      |   START ident &#39;\n&#39;                /* START     is %start                 */
      |   HEADCODE &#39;\n&#39;                   /* HEADCODE  is %{ Perl code ... %}    */
      |   UNION CODE &#39;\n&#39;                 /* UNION CODE  see yacc/bison          */
      |   DEFAULTACTION CODE &#39;\n&#39;         /* DEFAULTACTION is %defaultaction     */
      |   TREE treeclauses? &#39;\n&#39;          /* TREE      is %tree                  */
      |   METATREE &#39;\n&#39;                   /* METATREE  is %metatree              */
      |   TYPE typedecl identlist &#39;\n&#39;    /* TYPE      is %type                  */
      |   EXPECT NUMBER &#39;\n&#39;              /* EXPECT    is %expect                */
                                          /* NUMBER    is \d+                    */
  typedecl:   /* empty */
      |       &#39;&lt;&#39; IDENT &#39;&gt;&#39;
  treeclauses: BYPASS ALIAS? | ALIAS BYPASS?
  symlist:    symbol + 
  identlist:  ident +
  body:   rulesec ? &#39;%%&#39;
  rulesec:  startrules rules *
  startrules:  IDENT &#39;:&#39;  rhss &#39;;&#39;  
  rules:       IDENT &#39;:&#39; rhss &#39;;&#39;  
  rhss: rule &lt;+ &#39;|&#39;&gt;  
  rule:   optname rhs prec epscode 
      |   optname rhs         
  rhs:  rhselts ?   
  rhselts:  rhseltwithid + 
  rhseltwithid : 
        rhselt &#39;.&#39; IDENT 
      | &#39;$&#39; rhselt  
      | rhselt
  rhselt:     symbol    
      | code    
      | &#39;(&#39; optname rhs &#39;)&#39; 
      | rhselt STAR               /* STAR   is (%name\s*([A-Za-z_]\w*)\s*)?\*  */
      | rhselt &#39;&lt;&#39; STAR symbol &#39;&gt;&#39; 
      | rhselt OPTION             /* OPTION is (%name\s*([A-Za-z_]\w*)\s*)?\?  */
      | rhselt &#39;&lt;&#39; PLUS symbol &#39;&gt;&#39;
      | rhselt PLUS               /* PLUS   is (%name\s*([A-Za-z_]\w*)\s*)?\+  */
  optname: (NAME IDENT)?          /* NAME is %name */
         | NOBYPASS IDENT         /* NOBYPASS is %no\s+bypass */
  prec: PREC symbol               /* PREC is %prec */
  epscode:  code ?   
  code:   
      CODE           /* CODE     is { Perl code ... }         */
    | BEGINCODE      /* BEGINCODE is %begin { Perl code ... } */
  tail:  TAILCODE ?  /* TAILCODE is { Perl code ... } */
</pre>
<p class="POD_TEXT">
The semantic of <code>Eyapp</code> agrees with the semantic of <code>yacc</code> and <code>yapp</code>
for all the common constructions. For an introduction to the extensions
see <u>Parse::Eyapp::eyapptut</u>.
</p>
<p></p>
<h2 class="POD_HEAD1"><a name="The_Treeregexp_Langu">The Treeregexp Language</a></h2>
<p class="POD_TEXT">
A Treeregexp program is made of the repetition of three kind of 
tree primitives: The treeregexp transformations, auxiliar Perl code 
and Transformation Families.
</p>
<pre class="POD_VERBATIM">
  treeregexplist:  treeregexp*

  treeregexp: 
      IDENT &#39;:&#39; treereg (&#39;=&gt;&#39; CODE)?  # Treeregexp 
    | CODE                            # Auxiliar code
    | IDENT &#39;=&#39; IDENT + &#39;;&#39;           # Transformation families
</pre>
<p class="POD_TEXT">
Treeregexp themselves follow the rule:
</p>
<pre class="POD_VERBATIM">
                  IDENT &#39;:&#39; treereg (&#39;=&gt;&#39; CODE)?
</pre>
<p class="POD_TEXT">
Several instances of this rule can be seen in the example in
the <a class="POD_LINK" href="#SYNOPSIS">SYNOPSIS</a> section.
The identifier <code>IDENT</code> gives the name to the rule.
At the time of this writing (2006) there are the following kinds
of treeregexes:
</p>
<pre class="POD_VERBATIM">
  treereg: 
        /* tree patterns with children */
      IDENT &#39;(&#39; childlist &#39;)&#39; (&#39;and&#39; CODE)? 
    | REGEXP (&#39;:&#39; IDENT)? &#39;(&#39; childlist &#39;)&#39; (&#39;and&#39; CODE)? 
    | SCALAR &#39;(&#39; childlist &#39;)&#39; (&#39;and&#39; CODE)?  
    | &#39;.&#39; &#39;(&#39; childlist &#39;)&#39; (&#39;and&#39; CODE)? 
          /* leaf tree patterns */
    | IDENT (&#39;and&#39; CODE)? 
    | REGEXP (&#39;:&#39; IDENT)? (&#39;and&#39; CODE)? 
    | &#39;.&#39; (&#39;and&#39; CODE)? 
    | SCALAR (&#39;and&#39; CODE)? 
    | ARRAY 
    | &#39;*&#39;
</pre>
<h3 class="POD_HEAD2"><a name="Treeregexp_rules">Treeregexp rules</a></h3>
<p class="POD_TEXT">
When seen a rule like
</p>
<pre class="POD_VERBATIM">
    zero_times: TIMES(NUM($x), ., .) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
</pre>
<p class="POD_TEXT">
The Treeregexp translator creates a <code>Parse::Eyapp:YATW</code> object
that can be later referenced in the user code by the package variable
<code>$zero_times</code>.
</p>
<h4 class="POD_HEAD3"><a name="The_treeregexp">The treeregexp</a></h4>
<p class="POD_TEXT">
The first part of the rule <code>TIMES(NUM($x), ., .)</code>
indicates that for a matching to succeed the node being
visited must be of <code>type</code> <code>TIMES</code>, have a left child
of  <code>type</code> <code>NUM</code> and two more children.
</p>
<p class="POD_TEXT">
If the first part succeeded then the following part 
takes the control to see if the semantic conditions
are satisfied.
</p>
<h4 class="POD_HEAD3"><a name="Semantic_condition">Semantic condition</a></h4>
<p class="POD_TEXT">
The second part is optional and must be prefixed by the reserved word <code>and</code>
followed by a Perl code manifesting the semantic conditions that must be hold
by the node to succeed.
</p>
<h4 class="POD_HEAD3"><a name="Referencing_the_matc">Referencing the matching nodes</a></h4>
<p class="POD_TEXT">
The node  being visited can be referenced/modified
inside the semantic actions using <code>$_[0]</code>.
</p>
<p class="POD_TEXT">
The Treeregexp
translator automatically creates a set of lexical variables
for us. The scope of these variables is limited to the
semantic condition and the transformation code.
</p>
<p class="POD_TEXT">
Thus, the node being visited <code>$_[0]</code>
can be also referenced using the lexical variable
<code>$TIMES</code> which is created by he Treeregexp compiler.
In the same way a reference to the left child <code>NUM</code> will be stored
in the lexical variable <code>$NUM</code>and a
reference to the child of <code>$NUM</code> will be stored in <code>$x</code>.
</p>
<p class="POD_TEXT">
In the example the condition states that the attribute
of the node associated with <code>$x</code> must be zero.
</p>
<p class="POD_TEXT">
When the same type of node appears several times inside 
the treeregexp part the associated lexical variable is 
declared by the Treeregexp compiler as an array.
This is the case in the <code>constantfold</code> transformation
example, where there are two nodes of type <code>NUM</code>:
</p>
<pre class="POD_VERBATIM">
  constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($x), ., NUM($y))
     =&gt; {
    $x-&gt;{attr} = eval  &quot;$x-&gt;{attr} $W-&gt;{attr} $y-&gt;{attr}&quot;;
    $_[0] = $NUM[0];
  }
</pre>
<p class="POD_TEXT">
Thus variable  <code>$NUM[0]</code> references the first node
and  <code>$NUM[1]</code> the second.
</p>
<h4 class="POD_HEAD3"><a name="Transformation_code">Transformation code</a></h4>
<p class="POD_TEXT">
The third part of the rule is also optional and comes prefixed by
the big arrow <code>=&gt;</code>. The Perl code in this section usually 
transforms the matching tree.
To achieve the modification of the tree, the Treeregexp programmer
<b>must use <code>$_[0]</code></b> and not the lexical variables provided by the translator.
Remember that in Perl <code>$_[0]</code> is an alias of the actual parameter.
The <code>constantfold</code> example above <b>will not work</b> if we rewrite the code <code>$_[0] = $NUM[0]</code> as
</p>
<pre class="POD_VERBATIM">
                            { $TIMES = $NUM }
</pre>
<h3 class="POD_HEAD2"><a name="Regexp_Treeregexes">Regexp Treeregexes</a></h3>
<p class="POD_TEXT">
The previous <code>constantfold</code> example used a classic Perl linear regexp
to explicit that we want the root node to match the Perl regexp.
The general syntax for <code>REGEXP</code> treeregexes patters is:
</p>
<pre class="POD_VERBATIM">
      treereg: REGEXP (&#39;:&#39; IDENT)? &#39;(&#39; childlist &#39;)&#39; (&#39;and&#39; CODE)?
</pre>
<p class="POD_TEXT">
The <code>REGEXP</code> must be specified between slashes (other delimiters
as <code>{}</code> are not accepted).
It is legal to specify options after the second slash (like <code>e</code>, <code>i</code>, etc.).
</p>
<p class="POD_TEXT">
The operation of the ordinary string oriented regexps are slightly modified
when they are used inside a treeregexp.
<b>by default the option</b> 
<code>x</code> 
<b>will be assumed</b>.
The treeregexp compiler will automatically insert it.
Use the new option <code>X</code> (upper case X) if you want to supress such behavior.
<b>There is no need also to insert</b> <code>\b</code> 
<b>word anchors</b> to delimit identifiers:
all the identifiers in a regexp treeregexp are automatically
surrounded by <code>\b</code>. Use the option <code>B</code> (upper case B)
to supress this behavior.
</p>
<p class="POD_TEXT">
The optional identifier after the <code>REGEXP</code> indicates the name of the lexical variable
that will be held a reference to the node whose type matches <code>REGEXP</code>.
Variables <code>$W</code> and <code>@W</code> (if there are more than one REGEXP and or dot treeregexes)
will be used instead if no identifier is specified.
</p>
<p></p>
<h3 class="POD_HEAD2"><a name="Scalar_Treeregexes">Scalar Treeregexes</a></h3>
<p class="POD_TEXT">
A scalar treeregxp is defined writing a Perl scalar inside the treeregexp, like <code>$x</code>
in <code>NUM($x)</code>. A scalar treeregxp immediately matches any node that exists
and stores a reference to such node inside the Perl lexical scalar variable.
The scope of the variable is limited to the semantic parts of the Treeregexp.
Is illegal to use <code>$W</code> or <code>$W_#num</code> as variable names for scalar treeregexes.
</p>
<p></p>
<h3 class="POD_HEAD2"><a name="Dot_Treeregexes">Dot Treeregexes</a></h3>
<p class="POD_TEXT">
A dot matches any node. It can be seen as an abbreviation for
scalar treeregexes. The reference to the matching node
is stored in the lexical variable <code>$W</code>. 
The variable <code>@W</code> will be used instead
if there are more than one REGEXP and or dot treeregexes
</p>
<h3 class="POD_HEAD2"><a name="Array_Treeregexp_Exp">Array Treeregexp Expressions</a></h3>
<p class="POD_TEXT">
The Treeregexp language permits expressions like:
</p>
<pre class="POD_VERBATIM">
                   A(@a,B($x),@c)
</pre>
<p class="POD_TEXT">
After the matching variable <code>@A</code> contains the shortest prefix
of <code>$A-&gt;children</code> that does not match <code>B($x)</code>.
The variable <code>@c</code> contains the remaining sufix of<br>&nbsp;<code>$A-&gt;children</code>.
</p>
<h3 class="POD_HEAD2"><a name="Star_Treeregexp">Star Treeregexp</a></h3>
<p class="POD_TEXT">
Deprecated. Don&#39;t use it. Is still there but not to endure.
</p>
<h3 class="POD_HEAD2"><a name="Transformation_Famil">Transformation Families</a></h3>
<p class="POD_TEXT">
Transformations created by <code>Parse::Eyapp::Treeregexp</code> can be grouped in 
families. That is the function of the rule:
</p>
<pre class="POD_VERBATIM">
                    treeregexp: IDENT &#39;=&#39; IDENT + &#39;;&#39;
</pre>
<p></p>
<p class="POD_TEXT">
The next example (file <code>examples/TSwithtreetransformations3.eyp</code>)
defines the family
</p>
<pre class="POD_VERBATIM">
     algebraic_transformations = constantfold zero_times times_zero comasocfold;
</pre>
<p class="POD_TEXT">
Follows the code:
</p>
<pre class="POD_VERBATIM">
     my $transform = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{

      uminus: UMINUS(., NUM($x), .) =&gt; { $x-&gt;{attr} = -$x-&gt;{attr}; $_[0] = $NUM }
      constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($z), ., NUM($y))
         =&gt; {
        $z-&gt;{attr} = eval  &quot;$z-&gt;{attr} $W-&gt;{attr} $y-&gt;{attr}&quot;;
        $_[0] = $NUM[0];
      }
      commutative_add: PLUS($x, ., $y, .)
        =&gt; { my $t = $x; $_[0]-&gt;child(0, $y); $_[0]-&gt;child(2, $t)}
      comasocfold: TIMES(DIV(NUM($x), ., $b), ., NUM($y))
         =&gt; {
        $x-&gt;{attr} = $x-&gt;{attr} * $y-&gt;{attr};
        $_[0] = $DIV;
      }
      zero_times: TIMES(NUM($x), ., .) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
      times_zero: TIMES(., ., NUM($x)) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
      algebraic_transformations = constantfold zero_times times_zero comasocfold;
    },
    );

    $transform-&gt;generate();
    our ($uminus);
    $uminus-&gt;s($tree);
</pre>
<p></p>
<p class="POD_TEXT">
The transformations belonging to a family are usually applied 
toghether:
</p>
<pre class="POD_VERBATIM">
                $tree-&gt;s(@algebraic_transformations);
</pre>
<p></p>
<h3 class="POD_HEAD2"><a name="Code_Support">Code Support</a></h3>
<p class="POD_TEXT">
In between Treeregexp rules and family assignments the programmer can insert 
Perl code between curly brackets. That code usually gives support to
the semantic conditions and transformations inside the rules.
See for example test 14 in the <code>t/</code> directory of the Parse::Eyapp distribution.
</p>
<pre class="POD_VERBATIM">
  {
    sub not_semantic {
      my $self = shift;
      return  1 if $self-&gt;{token} eq $self-&gt;{attr};
      return 0;
    }
  }

  delete_tokens : TERMINAL and { not_semantic($TERMINAL) } 
                           =&gt; { $delete_tokens-&gt;delete() }
</pre>
<h2 class="POD_HEAD1"><a name="Parse_Eyapp_Methods"><code>Parse::Eyapp</code> Methods</a></h2>
<p class="POD_TEXT">
A <code>Parse::Eyapp</code> object holds the information 
about the <code>Eyapp</code> input grammar: parsing tables,
conflicts, semantic actions, etc.
</p>
<p></p>
<h3 class="POD_HEAD2"><a name="Parse_Eyapp_new_gram">Parse::Eyapp-&gt;new_grammar</a></h3>
<p class="POD_TEXT">
To translate an Eyapp grammar you must use
either the <a class="POD_LINK" href="eyapp.html">eyapp</a> script or call the class constructor 
<code>new_grammar</code>.
The <code>Parse::Eyapp</code> method <code>Parse::Eyapp-&gt;new_grammar(input=&gt;$grammar)</code> 
creates a package containing the code that implements a LALR parser
for the input grammar:
</p>
<pre class="POD_VERBATIM">
    my $p = Parse::Eyapp-&gt;new_grammar(
      input=&gt;$translationscheme,
      classname=&gt;&#39;Grammar&#39;,
    );
    die $p-&gt;Warnings if $p-&gt;Warnings;
    my $new_parser_for_grammar = Grammar-&gt;new();
</pre>
<p class="POD_TEXT">
The method returns a <code>Parse::Eyapp</code> object.
A <code>Parse::Eyapp</code> object describes the 
grammar and the parsing tables.
</p>
<p class="POD_TEXT">
You can check the object to see if there were
problems during the construction of the parser
for your grammar:
</p>
<pre class="POD_VERBATIM">
                die $p-&gt;qtables() if $p-&gt;Warnings;
</pre>
<p class="POD_TEXT">
The call to <code>Parse::Eyapp-&gt;new_grammar</code> generates
a class/package containing the parser for
your input grammar. Such package lives in the namespace 
determined by the <code>classname</code> argument
of <code>new_grammar</code>. <br>&nbsp;The method <code>Warnings</code> returns
the warnings produced during the parsing. The absence of warnings indicates
the correctness of the input program.
</p>
<p></p>
<dl class="POD_LIST">
<dt class="POD_ITEM"><a name="_input">-   input</a>
<dd>
The string containing the input
<dt class="POD_ITEM"><a name="_classname">-   classname</a>
<dd>
The name of the package that will held the code for the LALR parser.
The package of the caller will be used as default if none is specified.
<dt class="POD_ITEM"><a name="_firstline">-   firstline</a>
<dd>
For error diagnostics. The line where the definition of the Eyapp
grammar starts.
<dt class="POD_ITEM"><a name="_linenumbers">-   linenumbers</a>
<dd>
Include/not include  <code># line directives</code> in the generated code
<pre class="POD_VERBATIM">
  my $p = Parse::Eyapp-&gt;new_grammar(
    input=&gt;$translationscheme,
    classname=&gt;&#39;main&#39;,
    firstline =&gt; 6,
    outputfile =&gt; &#39;main&#39;);
  die $p-&gt;Warnings if $p-&gt;Warnings;
</pre>
<dt class="POD_ITEM"><a name="_outputfile">-   outputfile</a>
<dd>
If defined the generated code fill be dumped in the specified filename (with extension .pm)
and the LALR information ambigueties and conflicts) in the specified filename 
with extension .output.
</dl>
<h3 class="POD_HEAD2"><a name="_eyapp_qtables">$eyapp-&gt;qtables</a></h3>
<p class="POD_TEXT">
Returns a string containing information
on warnings, ambiguities, conflicts, rules and the generated DFA tables.
Is the same information in <code>file.output</code> when using the command 
<code>eyapp -v file.eyp</code>.
</p>
<pre class="POD_VERBATIM">
  my $p = Parse::Eyapp-&gt;new_grammar(
    input=&gt;$eyappprogram,
    classname=&gt;&#39;SimpleC&#39;,
    outputfile =&gt; &#39;SimpleC.pm&#39;,
    firstline=&gt;12,
  );

  print $p-&gt;qtables() if $p-&gt;Warnings;
</pre>
<h3 class="POD_HEAD2"><a name="_eyapp_outputtables">$eyapp-&gt;outputtables</a></h3>
<p class="POD_TEXT">
It receives two arguments
</p>
<pre class="POD_VERBATIM">
  $eyapp-&gt;outputtables($path, $base)
</pre>
<p class="POD_TEXT">
Similar to <code>qtables</code> but prints 
the information on warnings, conflicts and rules
to the specified <code>$path/$file</code>.
</p>
<h3 class="POD_HEAD2"><a name="_eyapp_Warnings">$eyapp-&gt;Warnings</a></h3>
<p class="POD_TEXT">
Returns the warnings resulting from compiling the grammar:
</p>
<pre class="POD_VERBATIM">
  my $p = Parse::Eyapp-&gt;new_grammar(
    input=&gt;$translationscheme,
    classname=&gt;&#39;main&#39;,
    firstline =&gt; 6,
    outputfile =&gt; &#39;main&#39;
  );
  die $p-&gt;Warnings if $p-&gt;Warnings;
</pre>
<p class="POD_TEXT">
Returns the empty string if there were no conflicts.
</p>
<h3 class="POD_HEAD2"><a name="_eyapp_ShowDfa">$eyapp-&gt;ShowDfa</a></h3>
<p class="POD_TEXT">
Returns a string with the information about the LALR generated
DFA.
Returns the empty string if there were no conflicts.
</p>
<h3 class="POD_HEAD2"><a name="_eyapp_Summary">$eyapp-&gt;Summary</a></h3>
<p class="POD_TEXT">
Returns a string with summary information about the compilation
of the grammar. No arguments.
</p>
<h3 class="POD_HEAD2"><a name="_eyapp_Conflicts">$eyapp-&gt;Conflicts</a></h3>
<p class="POD_TEXT">
Returns a string with summary information about the conflicts
that arised when compiling the grammar. No arguments.
</p>
<h3 class="POD_HEAD2"><a name="_eyapp_DfaTable">$eyapp-&gt;DfaTable</a></h3>
<p class="POD_TEXT">
Returns a string with the parsing tables
</p>
<h2 class="POD_HEAD1"><a name="Methods_Available_in">Methods Available in the Generated <code>Class</code></a></h2>
<p class="POD_TEXT">
This section describes the methods and objects belonging
to the class generated either using <a class="POD_LINK" href="eyapp.html">eyapp</a> 
or <code>Parse::Eyapp-&gt;new_grammar</code>. In the incoming paragraphs
we will assume that <code>Class</code> was the 
value selected for the <code>classname</code> argument
when <code>Parse::Eyapp-&gt;new_grammar</code> was called.
</p>
<p class="POD_TEXT">
Objects belonging to  <code>Class</code> are the actual parsers for the 
input grammar.
</p>
<h3 class="POD_HEAD2"><a name="Class_new">Class-&gt;new</a></h3>
<p class="POD_TEXT">
The method <code>Class-&gt;new</code> returns a new LALR parser object.
Here <code>Class</code> stands for the name of the class containing the parser.
See an example of call:
</p>
<pre class="POD_VERBATIM">
  my $parser = main-&gt;new(yyprefix =&gt; &#39;Parse::Eyapp::Node::&#39;,
                         yylex    =&gt; \&amp;main::_Lexer,
                         yyerror  =&gt; \&amp;main::_Error,
                         yydebug =&gt; 0x1F,
  );
</pre>
<p class="POD_TEXT">
The meaning of the arguments used in the example are as follows:
</p>
<dl class="POD_LIST">
<dt class="POD_ITEM"><a name="_yyprefix">- yyprefix</a>
<dd>
Used with %tree or %metatree. When used, the type names of the nodes of the syntax tree will
be build prefixing the value associated to <code>yyprefix</code> to the name of the production
rule. The name of the production rule is either explicitly given through a %name
directive or the concatenation of the left hand side of the rule with the
ordinal of the right hand side of the production.
<p class="POD_TEXT">
See files Rule9.yp, Transform4.trg and foldand0rule9_4.pl in the examples directory for
a more detailed example. File Rule9.yp is very much like the grammar
in the SYNOPSIS example but it makes use of the directive
<code>semantic tokens</code>:
</p>
<p class="POD_TEXT">
%semantic token &#39;=&#39; &#39;-&#39; &#39;+&#39; &#39;*&#39; &#39;/&#39;
</p>
<p></p>
<p class="POD_TEXT">
You need to compile the grammar Rule9.yp and the treeregexp
Transform4.trg using the commands:
</p>
<pre class="POD_VERBATIM">
  eyapp Rule9
  treereg -p &#39;Rule9::&#39; Transform4.trg
</pre>
<p class="POD_TEXT">
and the parser must be created inside the client program 
using the option <code>yyprefix</code>:
</p>
<pre class="POD_VERBATIM">
  use Rule9;
  use Transform4;

  my $parser = new Rule9(yyprefix =&gt; &quot;Rule9::&quot;);
  my $t=$parser-&gt;YYParse(yylex=&gt;\&amp;Rule9::Lexer,yyerror=&gt;\&amp;Rule9::Error,);
  $t-&gt;s(@Transform4::all);
</pre>
<p class="POD_TEXT">
Now the trees types are prefixed with &quot;Rule9::&quot;. After giving as input 
<code>a=2*3</code> to <code>foldand0rule9_4.pl</code> we will finally have a transformed tree
like this:
</p>
<pre class="POD_VERBATIM">
  bless( {
    &#39;children&#39; =&gt; [
      bless({&#39;children&#39;=&gt;[],&#39;attr&#39;=&gt;&#39;a&#39;,&#39;token&#39;=&gt;&#39;VAR&#39;},&#39;Rule9::TERMINAL&#39;),
      bless({&#39;children&#39;=&gt;[],&#39;attr&#39;=&gt;&#39;=&#39;,&#39;token&#39;=&gt;&#39;=&#39;},&#39;Rule9::TERMINAL&#39;),
      bless( {
        &#39;children&#39; =&gt; [
          bless({&#39;children&#39;=&gt;[],&#39;attr&#39;=&gt;6,&#39;token&#39;=&gt;&#39;NUM&#39;},&#39;Rule9::TERMINAL&#39;)
        ]
      }, &#39;Rule9::NUM&#39; )
    ]
  }, &#39;Rule9::ASSIGN&#39; );
</pre>
<dt class="POD_ITEM"><a name="_yylex">- yylex</a>
<dd>
Reference to the lexer subroutine
<dt class="POD_ITEM"><a name="_yyerror">- yyerror</a>
<dd>
Reference to the error subroutine. The error subroutine receives
as first argument the reference to the <code>Class</code> parser object.
This way it can take advantage of methods like <code>YYCurval</code>
and <a class="POD_LINK" href="#_parser_YYExpect">$parser-&gt;YYExpect</a> (see below):
<pre class="POD_VERBATIM">
  sub _Error {
    my($token)=$_[0]-&gt;YYCurval;
    my($what)= $token ? &quot;input: &#39;$token&#39;&quot; : &quot;end of input&quot;;
    my @expected = $_[0]-&gt;YYExpect();

    local $&quot; = &#39;, &#39;;
    die &quot;Syntax error near $what. Expected one of these tokens: @expected\n&quot;;
  }
</pre>
<dt class="POD_ITEM"><a name="_yydebug">- yydebug</a>
<dd>
Controls the level of debugging. It works as follows:
<pre class="POD_VERBATIM">
 /============================================================\
 | Bit Value  | Outputs                                       |
 |------------|-----------------------------------------------|
 |  0x01      |  Token reading (useful for Lexer debugging)   |
 |------------|-----------------------------------------------|
 |  0x02      |  States information                           |
 |------------|-----------------------------------------------|
 |  0x04      |  Driver actions (shifts, reduces, accept...)  |
 |------------|-----------------------------------------------|
 |  0x08      |  Parse Stack dump                             |
 |------------|-----------------------------------------------|
 |  0x10      |  Error Recovery tracing                       |
 \============================================================/
</pre>
<p class="POD_TEXT">
As an example consider the grammar (file PlusList1.yp in examples/)
</p>
<pre class="POD_VERBATIM">
  %%
  S:      &#39;c&#39;+  { print &quot;S -&gt; &#39;c&#39;+\n&quot; }
  ;
  %%
</pre>
<p class="POD_TEXT">
When the parser is called with <code>yyedebug</code> activated:
</p>
<pre class="POD_VERBATIM">
  $self-&gt;YYParse(yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error , yydebug =&gt; 0x1F);
</pre>
<p class="POD_TEXT">
the output reports about the parser activities:
</p>
<pre class="POD_VERBATIM">
  &gt; use_pluslist1.pl
  ----------------------------------------
  In state 0:
  Stack:[0]
  c
  Need token. Got &gt;c&lt;
  Shift and go to state 2.
  ----------------------------------------
  In state 2:
  Stack:[0,2]
  Don&#39;t need token.
  Reduce using rule 2 (PLUS-1,1): Back to state 0, then go to state 3.
  ----------------------------------------
  In state 3:
  Stack:[0,3]
  Need token. Got &gt;&lt;
  Reduce using rule 3 (S,1): S -&gt; &#39;c&#39;+
  Back to state 0, then go to state 1.
  ----------------------------------------
  In state 1:
  Stack:[0,1]
  Shift and go to state 4.
  ----------------------------------------
  In state 4:
  Stack:[0,1,4]
  Don&#39;t need token.
  Accept.
</pre>
</dl>
<p class="POD_TEXT">
The package produced from the grammar has several methods.
</p>
<p class="POD_TEXT">
The parser object has the following methods that work at parsing time
exactly as in <u>Parse::Yapp</u>. These methods can be found
in the module Parse::Eyapp::Driver. 
Assume you have in <code>$parser</code> the reference
to your parser object:
</p>
<h3 class="POD_HEAD2"><a name="_parser_YYParse_">$parser-&gt;YYParse()</a></h3>
<p class="POD_TEXT">
It very much works Parse::Yapp::YYParse and as yacc/bison yyparse.
It accepts almost the same arguments as <code>Class-</code>new&gt; with the exception
of <code>yyprefix</code> which can be used only with <code>new</code>.
</p>
<h3 class="POD_HEAD2"><a name="_parser_YYErrok">$parser-&gt;YYErrok</a></h3>
<p class="POD_TEXT">
Works as yacc/bison yyerrok. 
Modifies the error status
so that subsequent 
error messages will be emitted.
</p>
<h3 class="POD_HEAD2"><a name="_parser_YYError">$parser-&gt;YYError</a></h3>
<p class="POD_TEXT">
Works as yacc/bison YYERROR.
Pretends that a syntax error has been detected.
</p>
<h3 class="POD_HEAD2"><a name="_parser_YYNberr">$parser-&gt;YYNberr</a></h3>
<p class="POD_TEXT">
The current number of errors
</p>
<h3 class="POD_HEAD2"><a name="_parser_YYAccept">$parser-&gt;YYAccept</a></h3>
<p class="POD_TEXT">
Works as yacc/bison YYACCEPT.
The parser finishes returning 
the current semantic value to indicate success.
</p>
<p></p>
<h3 class="POD_HEAD2"><a name="_parser_YYAbort">$parser-&gt;YYAbort</a></h3>
<p class="POD_TEXT">
Works as yacc/bison YYABORT. 
The parser finishes returning 
<code>undef</code> to indicate failure.
</p>
<h3 class="POD_HEAD2"><a name="_parser_YYRecovering">$parser-&gt;YYRecovering</a></h3>
<p class="POD_TEXT">
Works as yacc/bison YYRECOVERING.
Returns TRUE if the parser is recovering from a syntax error.
</p>
<h3 class="POD_HEAD2"><a name="_parser_YYCurtok">$parser-&gt;YYCurtok</a></h3>
<p class="POD_TEXT">
Gives the current token
</p>
<h3 class="POD_HEAD2"><a name="_parser_YYCurval">$parser-&gt;YYCurval</a></h3>
<p class="POD_TEXT">
Gives the attribute associated with the current token
</p>
<h3 class="POD_HEAD2"><a name="_parser_YYExpect">$parser-&gt;YYExpect</a></h3>
<p class="POD_TEXT">
Is a list which contains the tokens the parser 
expected when the failure occurred
</p>
<pre class="POD_VERBATIM">
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \
                            sed -ne &#39;26,33p&#39; Postfix.eyp
 sub _Error {
   my($token)=$_[0]-&gt;YYCurval;
   my($what)= $token ? &quot;input: &#39;$token&#39;&quot; : &quot;end of input&quot;;
   my @expected = $_[0]-&gt;YYExpect();

   local $&quot; = &#39;, &#39;;
   die &quot;Syntax error near $what. Expected one of these tokens: @expected\n&quot;;
 }
</pre>
<p></p>
<h3 class="POD_HEAD2"><a name="_parser_YYLexer">$parser-&gt;YYLexer</a></h3>
<p class="POD_TEXT">
Returns a reference to the lexical analyzer
</p>
<h3 class="POD_HEAD2"><a name="_parser_YYLhs">$parser-&gt;YYLhs</a></h3>
<p class="POD_TEXT">
Returns the identifier of the left hand side of the current production (the one
that is being used for reduction/antiderivation. An example 
of use can be found in examples/Lhs1.yp:
</p>
<pre class="POD_VERBATIM">
  %defaultaction { print $_[0]-&gt;YYLhs,&quot;\n&quot; }
</pre>
<h3 class="POD_HEAD2"><a name="_parser_YYRuleindex">$parser-&gt;YYRuleindex</a></h3>
<p class="POD_TEXT">
Returns the index of the production rule, counting the super rule as rule 0.
To know the numbers have a look at  the <code>.output</code> file.
To get a <code>.output</code> file use the option <code>-v</code> of <code>eyapp</code> or the <code>outputfile</code>
parameter when using method <code>new_grammar</code>.
</p>
<h3 class="POD_HEAD2"><a name="_parser_YYRightside">$parser-&gt;YYRightside</a></h3>
<p class="POD_TEXT">
Returns an array of strings describing the right hand side of the rule
</p>
<h3 class="POD_HEAD2"><a name="_parser_YYIsterm">$parser-&gt;YYIsterm</a></h3>
<p class="POD_TEXT">
Returns TRUE  if the symbol given as argument is a terminal. Example:
</p>
<pre class="POD_VERBATIM">
  DB&lt;0&gt; x $self-&gt;YYIsterm(&#39;exp&#39;)
 0  &#39;&#39;
  DB&lt;1&gt; x $self-&gt;YYIsterm(&#39;*&#39;)
 0  1
</pre>
<p></p>
<p class="POD_TEXT">
An example of combined 
use of <code>YYRightside</code>, <code>YYRuleindex</code>, <code>YYLhs</code> and <code>YYIsterm</code>
can be found <code>examples/Rule3.yp</code>:
</p>
<pre class="POD_VERBATIM">
  sub build_node {
    my $self = shift;
    my @children = @_;
    my @right = $self-&gt;YYRightside();
    my $var = $self-&gt;YYLhs;
    my $rule = $self-&gt;YYRuleindex();

    for(my $i = 0; $i &lt; @right; $i++) {
      $_ = $right[$i];
      if ($self-&gt;YYIsterm($_)) {
        $children[$i] = bless { token =&gt; $_, attr =&gt; $children[$i] }, 
                                            __PACKAGE__.&#39;::TERMINAL&#39;;
      }
    }
    bless {
            children =&gt; \@children,
            info =&gt; &quot;$var -&gt; @right&quot;
          }, __PACKAGE__.&quot;::${var}_$rule&quot;
  }
</pre>
<h3 class="POD_HEAD2"><a name="_parser_YYIssemantic">$parser-&gt;YYIssemantic</a></h3>
<p class="POD_TEXT">
Returns TRUE if the terminal is semantic. Semantics token can be declared
using the directive <code>%semantic token</code>. The opposite of a Semantic token
is a Syntactic token. Syntactic tokens can be declared
using the directive  <code>%syntactic token</code>.
</p>
<p class="POD_TEXT">
When using the <code>%tree</code> directive all the nodes corresponding to syntactic
tokens are pruned from the tree. When using the <code>%tree</code> directive
string tokens (those that appear
in the text of the grammar delimited by simple quotes) are considered, 
by default, syntactic tokens.
</p>
<p class="POD_TEXT">
When using the <code>%metatree</code> directive all the tokens 
are considered, by default, semantic tokens.
Thus, no nodes will be - by default- pruned when construction
the code augmented tree. The exception are string tokens
used as separators in the definition of
lists,  like in <code>S &lt;* &#39;;&#39;&gt;</code>. If you want the separating string token
to appear include an explicit semantic declaration for it (example <code>%semantic token &#39;;&#39;</code>).
</p>
<h3 class="POD_HEAD2"><a name="_parser_YYName">$parser-&gt;YYName</a></h3>
<p class="POD_TEXT">
Returns the name of the current rule
</p>
<pre class="POD_VERBATIM">
  DB&lt;12&gt; x $self-&gt;YYName
 0  &#39;exp_11&#39;
</pre>
<h3 class="POD_HEAD2"><a name="_parser_YYPrefix">$parser-&gt;YYPrefix</a></h3>
<p class="POD_TEXT">
Return and/or sets the <code>yyprefix</code> attribute. This a string that will be concatenated
as a prefix to any <code>Parse::Eyapp::Node</code> nodes in the syntax tree.
</p>
<h3 class="POD_HEAD2"><a name="_parser_YYBypass">$parser-&gt;YYBypass</a></h3>
<p class="POD_TEXT">
Returns TRUE if running under the <code>%tree bypass</code> clause
</p>
<h3 class="POD_HEAD2"><a name="_parser_YYBypassrule">$parser-&gt;YYBypassrule</a></h3>
<p class="POD_TEXT">
Returns TRUE if the production being
used for reduction was marked to be bypassed.
</p>
<h3 class="POD_HEAD2"><a name="_parser_YYFirstline">$parser-&gt;YYFirstline</a></h3>
<p class="POD_TEXT">
First line of the input string describing the grammar
</p>
<h3 class="POD_HEAD2"><a name="_parser_BeANode">$parser-&gt;BeANode</a></h3>
<p class="POD_TEXT">
Receives as input a <code>Class</code> name. 
Introduces <code>Parse::Eyapp::Node</code> as an ancestor class
of <code>Class</code>
</p>
<h3 class="POD_HEAD2"><a name="_parser_YYBuildAST">$parser-&gt;YYBuildAST</a></h3>
<p class="POD_TEXT">
Sometimes the best time to decorate a node with some attributes is just
after being built. In such cases the programmer can take manual control
building the node with <code>YYBuildAST</code> to inmediately proceed to decorate it.
</p>
<p class="POD_TEXT">
The following example illustrates the situation:
</p>
<pre class="POD_VERBATIM">
 Variable:
     %name  VARARRAY
     $ID (&#39;[&#39; binary &#39;]&#39;) &lt;%name INDEXSPEC +&gt;
       {
         my $self = shift;
         my $node =  $self-&gt;YYBuildAST(@_);
         $node-&gt;{line} = $ID-&gt;[1];
         return $node;
       }
</pre>
<p class="POD_TEXT">
Actually, the <code>%tree</code> directive is semantically equivalent to:
</p>
<pre class="POD_VERBATIM">
  %default action { goto &amp;Parse::Eyapp::Driver::YYBuildAST }
</pre>
<h3 class="POD_HEAD2"><a name="_parser_YYBuildTS">$parser-&gt;YYBuildTS</a></h3>
<p class="POD_TEXT">
Similar to <code>$parser-&gt;YYBuildAST</code> but for translation schemes.
</p>
<p></p>
<h2 class="POD_HEAD1"><a name="Parse_Eyapp_Parse_ob"><code>Parse::Eyapp::Parse</code> objects</a></h2>
<p class="POD_TEXT">
The parser for the <code>Eyapp</code> language
was written and generated
using <code>Parse::Eyapp</code> and the <code>eyapp</code> compiler (actually
the first version 
was bootstrapped using the <u>yapp</u> compiler).
The grammar describing the <code>Eyapp</code> language
is in the file <code>Parse/Eyapp/Parse.yp</code> 
in the <code>Parse::Eyapp</code> distribution.
Therefore <code>Parse::Eyapp::Parse</code> 
objects have all the methods mentioned 
in the section &quot;<a class="POD_LINK" href="#Methods_Available_in">Methods Available in the Generated <code>Class</code></a>&quot;.
A <code>Parse::Eyapp::Parse</code> is nothing but a particular kind of <code>Parse::Eyapp</code>
parser: <i>the one that parses</i> <code>Eyapp</code> <i>grammars</i>.
</p>
<p></p>
<h2 class="POD_HEAD1"><a name="Parse_Eyapp_Node_Met">Parse::Eyapp::Node Methods</a></h2>
<p class="POD_TEXT">
The <code>Parse::Eyapp::Node</code> objects represent the nodes of the syntax
tree. 
All the node classes build by <code>%tree</code> and <code>%metatree</code> directives
inherit from <code>Parse::Eyapp::Node</code> and consequently have
acces to the methods provided in such module.
</p>
<h3 class="POD_HEAD2"><a name="Parse_Eyapp_Node_new">Parse::Eyapp::Node-&gt;new</a></h3>
<p class="POD_TEXT">
Nodes are usually created using the <code>%tree</code> or <code>%metatree</code>
<code>Parse::Eyapp</code> directives. The <code>Parse::Eyapp::Node</code> constructor <code>new</code>
offers an alternative way to create forests.
</p>
<p class="POD_TEXT">
This class method can be used to build multiple nodes on a row.
It receives a string describing the tree and optionally a
reference to a subroutine. Such subroutine (called the attribute
handler) is in charge to initialize
the attributes of the just created nodes.
The attribute handler is called with the array of references to the
nodes as they appear in the string from left to right.
</p>
<p class="POD_TEXT">
<code>Parse::Eyapp::Node-&gt;new</code> returns an array of pointers to the nodes created
as they appear in the input string from left to right.
In scalar context returns a pointer to the first tree.
</p>
<p class="POD_TEXT">
The following example (see file <code>examples/28foldwithnewwithvars.pl</code>) of
a treeregexp transformations creates a new <code>NUM(TERMINAL)</code> node
using <code>Parse::Eyapp::Node-&gt;new</code>:
</p>
<pre class="POD_VERBATIM">
 my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
   {
     my %Op = (PLUS=&gt;&#39;+&#39;, MINUS =&gt; &#39;-&#39;, TIMES=&gt;&#39;*&#39;, DIV =&gt; &#39;/&#39;);
   }
   constantfold: /TIMES|PLUS|MINUS|DIV/(NUM($x), NUM($y))
      =&gt; {
     my $op = $Op{ref($_[0])};

     my $res = Parse::Eyapp::Node-&gt;new(
       q{NUM(TERMINAL)},
       sub {
         my ($NUM, $TERMINAL) = @_;
         $TERMINAL-&gt;{attr} = eval &quot;$x-&gt;{attr} $op $y-&gt;{attr}&quot;;
         $TERMINAL-&gt;{token} = &#39;NUM&#39;;
       },
     );
     $_[0] = $res;
   }
   },
 );
</pre>
<p class="POD_TEXT">
The string can describe more than one tree like in:
</p>
<pre class="POD_VERBATIM">
   my @t = Parse::Eyapp::Node-&gt;new(
            &#39;A(C,D) E(F)&#39;, sub { my $i = 0; $_-&gt;{n} = $i++ for @_ });
</pre>
<p class="POD_TEXT">
The following trees will be built:
</p>
<pre class="POD_VERBATIM">
        bless( { &#39;n&#39; =&gt; 0,
          &#39;children&#39; =&gt; [
            bless( { &#39;n&#39; =&gt; 1, &#39;children&#39; =&gt; [] }, &#39;C&#39; ),
            bless( { &#39;n&#39; =&gt; 2, &#39;children&#39; =&gt; [] }, &#39;D&#39; )
          ]
        }, &#39;A&#39; );
        bless( { &#39;n&#39; =&gt; 3,
          &#39;children&#39; =&gt; [
            bless( { &#39;n&#39; =&gt; 4, &#39;children&#39; =&gt; [] }, &#39;F&#39; )
          ]
        }, &#39;E&#39; );
</pre>
<p class="POD_TEXT">
and <code>@t</code> will contain 5 references to the corresponding subtrees 
A(C,D), C, D, E(F) and F.
</p>
<h3 class="POD_HEAD2"><a name="Parse_Eyapp_Node_hne"><code>Parse::Eyapp::Node-&gt;hnew</code></a></h3>
<p class="POD_TEXT">
<code>Parse::Eyapp</code> provides the method <code>Parse::Eyapp::Node-&gt;hnew</code>
to build DAGs instead of trees. It is built using 
<i>hashed consing</i>. It works very much like <code>Parse::Eyapp::Node-&gt;new</code>
but if one of the implied trees was previously built, <code>hnew</code> 
returns a reference to the existing one.
See the following debugger session where several DAGs describing
<i>type expressions</i> are built:
</p>
<pre class="POD_VERBATIM">
  DB&lt;2&gt; x $a = Parse::Eyapp::Node-&gt;hnew(&#39;F(X_3(A_3(A_5(INT)), CHAR, A_5(INT)),CHAR)&#39;)
 0  F=HASH(0x85f6a20)
    &#39;children&#39; =&gt; ARRAY(0x85e92e4)
    |- 0  X_3=HASH(0x83f55fc)
    |     &#39;children&#39; =&gt; ARRAY(0x83f5608)
    |     |- 0  A_3=HASH(0x85a0488)
    |     |     &#39;children&#39; =&gt; ARRAY(0x859fad4)
    |     |        0  A_5=HASH(0x85e5d3c)
    |     |           &#39;children&#39; =&gt; ARRAY(0x83f4120)
    |     |              0  INT=HASH(0x83f5200)
    |     |                 &#39;children&#39; =&gt; ARRAY(0x852ccb4)
    |     |                      empty array
    |     |- 1  CHAR=HASH(0x8513564)
    |     |     &#39;children&#39; =&gt; ARRAY(0x852cad4)
    |     |          empty array
    |     `- 2  A_5=HASH(0x85e5d3c)
    |           -&gt; REUSED_ADDRESS
    `- 1  CHAR=HASH(0x8513564)
          -&gt; REUSED_ADDRESS
  DB&lt;3&gt; x $a-&gt;str
 0  &#39;F(X_3(A_3(A_5(INT)),CHAR,A_5(INT)),CHAR)&#39;
</pre>
<p class="POD_TEXT">
The second occurrence of <code>A_5(INT)</code> is labelled <code>REUSED_ADDRESS</code>. The
same occurs with the second instance  of <code>CHAR</code>. <code>Parse::Eyapp::Node-&gt;hnew</code>
can be more convenient than <code>new</code> 
when dealing with optimizations like <i>common subexpressions</i>
or during <i>type checking</i>.
</p>
<p></p>
<h3 class="POD_HEAD2"><a name="_node_type">$node-&gt;type</a></h3>
<p class="POD_TEXT">
Returns the type of the node.
It can be called as a sub when <code>$node</code> is not
a <code>Parse::Eyapp::Node</code> like this:
</p>
<pre class="POD_VERBATIM">
                     Parse::Eyapp::Node::type($scalar)
</pre>
<p class="POD_TEXT">
This is the case when visiting <code>CODE</code> nodes.
</p>
<p class="POD_TEXT">
The following session with the debugger illustrates how it works:
</p>
<pre class="POD_VERBATIM">
  &gt; perl -MParse::Eyapp::Node -de0
  DB&lt;1&gt; @t = Parse::Eyapp::Node-&gt;new(&quot;A(B,C)&quot;) # Creates a tree
  DB&lt;2&gt; x map { $_-&gt;type } @t # Get the types of the three nodes
  0  &#39;A&#39;
  1  &#39;B&#39;
  2  &#39;C&#39;
  DB&lt;3&gt; x Parse::Eyapp::Node::type(sub {})
  0  &#39;CODE&#39;
  DB&lt;4&gt; x Parse::Eyapp::Node::type(&quot;hola&quot;)
  0  &#39;Parse::Eyapp::Node::STRING&#39;
  DB&lt;5&gt; x Parse::Eyapp::Node::type({ a=&gt; 1})
  0  &#39;HASH&#39;
  DB&lt;6&gt; x Parse::Eyapp::Node::type([ a, 1 ])
  0  &#39;ARRAY&#39;
</pre>
<p class="POD_TEXT">
As it is shown in the example it can be called as a subroutine with 
a (code/hash/array) reference or an ordinary scalar.
</p>
<p class="POD_TEXT">
The words HASH, CODE, ARRAY and STRING are reserved for 
ordinary Perl references. Avoid naming a node with one of those words.
</p>
<h3 class="POD_HEAD2"><a name="_node_child">$node-&gt;child</a></h3>
<p class="POD_TEXT">
Setter-getter to modify a specific child of a node.
It is called like:
</p>
<pre class="POD_VERBATIM">
                   $node-&gt;child($i)
</pre>
<p class="POD_TEXT">
Returns the child with index $i. Returns <code>undef</code> if the child does not exists.
It has two obligatory parameters: the node (since it is a method)
and the index of the child. Sets teh new value if called
</p>
<pre class="POD_VERBATIM">
                    $node-&gt;child($i, $tree)
</pre>
<p class="POD_TEXT">
The method will croak if the obligatory parameters are not provided.
Follows an example of use inside a Treereg program (see
file <code>examples/TSwithtreetransformations2.eyp</code>:
</p>
<pre class="POD_VERBATIM">
  my $transform = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
     commutative_add: PLUS($x, ., $y, .) # 1st . = &#39;+&#39; 2nd . = CODE
       =&gt; { my $t = $x; $_[0]-&gt;child(0, $y); $_[0]-&gt;child(2, $t)}
  }
</pre>
<h3 class="POD_HEAD2"><a name="Child_Access_Through">Child Access Through <code>%tree alias</code></a></h3>
<p class="POD_TEXT">
Remember that when the <code>Eyapp</code> program runs 
under the <code>%tree alias</code> directive 
The dot and dollar notations can be used 
to generate named getter-setters to access the children:
</p>
<pre class="POD_VERBATIM">
  %tree bypass alias
  .... 
  %%
  exp: %name PLUS
         exp.left &#39;+&#39; exp.right
  ....
  %%
  .... # and later
  print $exp-&gt;left-&gt;str;
</pre>
<p class="POD_TEXT">
Here methods with names <code>left</code> and <code>right</code> will be created
to access the corresponding children associated with the 
two instances of <code>exp</code> in the right hand side of
the production rule.
</p>
<h3 class="POD_HEAD2"><a name="_node_children">$node-&gt;children</a></h3>
<p class="POD_TEXT">
Returns the array of children of the node. When the tree is a
translation scheme the CODE references are also included.
See <code>examples/TSPostfix3.eyp</code> for an example of use
inside a Translation Scheme:
</p>
<pre class="POD_VERBATIM">
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$\
                       sed -ne &#39;31,34p&#39; TSPostfix3.eyp
 line: %name PROG
        exp &lt;%name EXP + &#39;;&#39;&gt;
          { @{$lhs-&gt;{t}} = map { $_-&gt;{t}} ($_[1]-&gt;children()); }
</pre>
<p class="POD_TEXT">
The tree in a Translation Scheme contains the references to
the <code>CODE</code> implementing the semantic actions.
For example,  the syntax tree built by 
the parser for the input <code>a=-b*3</code> in <code>TSPostfix3.eyp</code> is:
</p>
<pre class="POD_VERBATIM">
 PROG(EXP(
     ASSIGN(
       TERMINAL[a],
       TERMINAL[=],
       TIMES(
         NEG(TERMINAL[-], VAR(TERMINAL[b], CODE), CODE),
         TERMINAL[*],
         NUM(TERMINAL[3], CODE),
         CODE
       ) # TIMES,
       CODE
     ) # ASSIGN
   ) # EXP,
   CODE
 ) # PROG
</pre>
<p class="POD_TEXT">
<code>$node-&gt;children</code> can also be used as a setter.
</p>
<h3 class="POD_HEAD2"><a name="_node_Children">$node-&gt;Children</a></h3>
<p class="POD_TEXT">
Returns the array of children of the node.
When dealing with a translation scheme,
the  $node-&gt;Children method (first in uppercase) returns the non
CODE children of the node.
</p>
<h3 class="POD_HEAD2"><a name="_node_last_child">$node-&gt;last_child</a></h3>
<p class="POD_TEXT">
Return the last child of the node. When dealing with translation
schemes, the last can be a <code>CODE</code> node.
</p>
<h3 class="POD_HEAD2"><a name="_node_Last_child">$node-&gt;Last_child</a></h3>
<p class="POD_TEXT">
The <code>$node-&gt;Last_child</code> method returns the last non CODE child of the node.
See an example:
</p>
<pre class="POD_VERBATIM">
  line:       %name EXP
                exp &lt;+ &#39;;&#39;&gt; /* Expressions separated by semicolons */
            { $lhs-&gt;{n} = $_[1]-&gt;Last_child-&gt;{n} }
  ;
</pre>
<h3 class="POD_HEAD2"><a name="_node_descendant">$node-&gt;descendant</a></h3>
<p class="POD_TEXT">
The <code> descendant</code> method 
returns the descendant of a node given its <i>coordinates</i>. 
The coordinates of a node <code>$s</code> relative to a tree <code>$t</code>
to which it belongs is a string of numbers
separated by dots like  <code>&quot;.1.3.2&quot;</code> which
denotes the <i>child path</i> from <code>$t</code> to <code>$s</code>, i.e.
<code>$s == $t-&gt;child(1)-&gt;child(3)-&gt;child(2)</code>.
</p>
<p class="POD_TEXT">
See a session
with the debugger:
</p>
<pre class="POD_VERBATIM">
   DB&lt;7&gt; x $t-&gt;child(0)-&gt;child(0)-&gt;child(1)-&gt;child(0)-&gt;child(2)-&gt;child(1)-&gt;str
 0  &#39;
 BLOCK[8:4:test]^{0}(
   CONTINUE[10,10]
 )
   DB&lt;8&gt; x $t-&gt;descendant(&#39;.0.0.1.0.2.1&#39;)-&gt;str
 0  &#39;
 BLOCK[8:4:test]^{0}(
   CONTINUE[10,10]
</pre>
<h3 class="POD_HEAD2"><a name="_node_str">$node-&gt;str</a></h3>
<p class="POD_TEXT">
The <code>str</code> method returns a string representation of the tree. 
The <i>str</i> method traverses the syntax tree dumping the type
of the node being visited in a string. If the node being visited
has a method <code>info</code> it will
be executed and its result inserted between <code>$DELIMITER</code>s
into the string. Thus, in the <a class="POD_LINK" href="#SYNOPSIS">SYNOPSIS</a>
example, by adding the <code>info</code> method to the class <code>TERMINAL</code>:
</p>
<pre class="POD_VERBATIM">
 sub TERMINAL::info {
   $_[0]{attr}
 }
</pre>
<p class="POD_TEXT">
we achieve the insertion of attributes in the string being built 
by <code>str</code>.
</p>
<p class="POD_TEXT">
The existence of some methods (like <code>footnote</code>) and
the values of some package variables
influence the behavior of <code>str</code>. Among the most
important are:
</p>
<pre class="POD_VERBATIM">
  @PREFIXES = qw(Parse::Eyapp::Node::); # Prefixes to supress 
  $INDENT = 0; # 0 = compact, 1 = indent, 2 = indent and include Types in closing parenthesis
  $STRSEP = &#39;,&#39;; # Separator between nodes, by default a comma
  $DELIMITER = &#39;[&#39;; # The string returned by C&lt;info&gt; will be enclosed 
  $FOOTNOTE_HEADER = &quot;\n---------------------------\n&quot;; 
  $FOOTNOTE_SEP = &quot;)\n&quot;; 
  $FOOTNOTE_LEFT = &#39;^{&#39;; # Left delimiter for a footnote number
  $FOOTNOTE_RIGHT = &#39;}&#39;; # Right delimiter for a footnote number
  $LINESEP = 4; # When indent=2 the enclosing parenthesis will be
                # commented if more than $LINESEP apart
</pre>
<p class="POD_TEXT">
The following list defines the <code>$DELIMITER</code>s you can choose for 
attribute representation:
</p>
<pre class="POD_VERBATIM">
          &#39;[&#39; =&gt; &#39;]&#39;, &#39;{&#39; =&gt; &#39;}&#39;, &#39;(&#39; =&gt; &#39;)&#39;, &#39;&lt;&#39; =&gt; &#39;&gt;&#39;
</pre>
<p class="POD_TEXT">
If the node being visited has a method  <code>footnote</code>, the string
returned by the method will be concatenated at the end of the 
string as a footnote. The variables <code>$FOOTNOTE_LEFT</code> and
<code>$FOOTNOTE_RIGHT</code> govern the displaying of footnote numbers.
</p>
<p class="POD_TEXT">
Follows an example of output using <code>footnotes</code>.
</p>
<pre class="POD_VERBATIM">
 nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple-Types/script&gt; \
                                          usetypes.pl prueba24.c
 PROGRAM^{0}(FUNCTION[f]^{1}(RETURNINT(TIMES(INUM(TERMINAL[2:2]),VAR(TERMINAL[a:2])))))
 ---------------------------
 0)
 Types:
 $VAR1 = {
   &#39;CHAR&#39; =&gt; bless( {
     &#39;children&#39; =&gt; []
   }, &#39;CHAR&#39; ),
   &#39;VOID&#39; =&gt; bless( {
     &#39;children&#39; =&gt; []
   }, &#39;VOID&#39; ),
   &#39;INT&#39; =&gt; bless( {
     &#39;children&#39; =&gt; []
   }, &#39;INT&#39; ),
   &#39;F(X_1(INT),INT)&#39; =&gt; bless( {
     &#39;children&#39; =&gt; [
       bless( {
         &#39;children&#39; =&gt; [
           $VAR1-&gt;{&#39;INT&#39;}
         ]
       }, &#39;X_1&#39; ),
       $VAR1-&gt;{&#39;INT&#39;}
     ]
   }, &#39;F&#39; )
 };
 Symbol Table:
 $VAR1 = {
   &#39;f&#39; =&gt; {
     &#39;type&#39; =&gt; &#39;F(X_1(INT),INT)&#39;,
     &#39;line&#39; =&gt; 1
   }
 };

 ---------------------------
 1)
 $VAR1 = {
   &#39;a&#39; =&gt; {
     &#39;type&#39; =&gt; &#39;INT&#39;,
     &#39;param&#39; =&gt; 1,
     &#39;line&#39; =&gt; 1
   }
 };
</pre>
<p class="POD_TEXT">
The first footnote was due to a call to <code>PROGRAM:footnote</code>.
The <code>footnote</code> method for the <code>PROGRAM</code> node was defined as:
</p>
<pre class="POD_VERBATIM">
 nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple-Types/lib/Simple&gt; \
                             sed -n -e &#39;691,696p&#39; Types.eyp | cat -n
     1  sub PROGRAM::footnote {
     2    return &quot;Types:\n&quot;
     3           .Dumper($_[0]-&gt;{types}).
     4           &quot;Symbol Table:\n&quot;
     5           .Dumper($_[0]-&gt;{symboltable})
     6  }
</pre>
<p class="POD_TEXT">
The second footnote was produced by the existence of a
<code>FUNCTION::footnote</code> method:
</p>
<pre class="POD_VERBATIM">
 nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple-Types/lib/Simple&gt; \
                            sed -n -e &#39;702,704p&#39; Types.eyp | cat -n
 1  sub FUNCTION::footnote {
 2    return Dumper($_[0]-&gt;{symboltable})
 3  }
</pre>
<p></p>
<p class="POD_TEXT">
The source program for the example was:
</p>
<pre class="POD_VERBATIM">
     1  int f(int a) {
     2    return 2*a;
     3  }
</pre>
<p></p>
<h3 class="POD_HEAD2"><a name="_node_delete_child_">$node-&gt;delete($child)</a></h3>
<p class="POD_TEXT">
The <code>delete</code> method is used to delete the specified child of <code>$node</code>.
The child to delete can be specified using the index or a
reference. It returns the deleted child.
</p>
<p class="POD_TEXT">
Throws an exception if the object can&#39;t do <code>children</code> or has no <code>children</code>.
See also the <a class="POD_LINK" href="#_yatw_delete">delete</a> method of treeregexes 
(<code>Parse::Eyapp:YATW</code> objects)
to delete the node being visited.
</p>
<p class="POD_TEXT">
The following example moves out of a loop an assignment statement
assuming is an invariant of the loop. To do it uses
the <code>delete</code> and <code>insert_before</code> methods:
</p>
<pre class="POD_VERBATIM">
  nereida:~/src/perl/YappWithDefaultAction/examples&gt; \
              sed -ne &#39;98,113p&#39; moveinvariantoutofloopcomplexformula.pl
  my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
    moveinvariant: BLOCK(
                     @prests,
                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
                     @possts
                   )
      =&gt; {
           my $assign = $ASSIGN;
           $BLOCK[1]-&gt;delete($ASSIGN);
           $BLOCK[0]-&gt;insert_before($WHILE, $assign);
         }
    },
    FIRSTLINE =&gt; 99,
  );
  $p-&gt;generate();
  $moveinvariant-&gt;s($t);
</pre>
<p class="POD_TEXT">
The example below deletes CODE nodes
from the tree build for a translation scheme:
</p>
<pre class="POD_VERBATIM">
  my $transform = Parse::Eyapp::Treeregexp-&gt;new( 
    STRING=&gt;q{delete_code: CODE =&gt; { Parse::Eyapp::Node::delete($CODE) }},
  )
</pre>
<p class="POD_TEXT">
Observe how delete is called as a subroutine.
</p>
<h3 class="POD_HEAD2"><a name="_node_unshift_newchi">$node-&gt;unshift($newchild)</a></h3>
<p class="POD_TEXT">
Inserts <code>$newchild</code> at the beginning of the list of children of <code>$node</code>.
See also the <a class="POD_LINK" href="#_yatw_unshift_b_">unshift</a> method 
for <code>Parse::Eyapp:YATW</code> treeregexp transformation objects
</p>
<h3 class="POD_HEAD2"><a name="_node_push_newchild_">$node-&gt;push($newchild)</a></h3>
<p class="POD_TEXT">
Inserts <code>$newchild</code> at the end of the list of children of <code>$node</code>.
</p>
<h3 class="POD_HEAD2"><a name="_node_insert_before_">$node-&gt;insert_before($position, $new_child)</a></h3>
<p class="POD_TEXT">
Inserts <code>$newchild</code> before <code>$position</code> in the list of children of <code>$node</code>.
Variable <code>$position</code> can be an index or a reference.
</p>
<p class="POD_TEXT">
The method throws an exception if <code>$position</code> is an index
and is not in range. Also if <code>$node</code> has no children.
</p>
<p class="POD_TEXT">
The method throws a warning if <code>$position</code> is a reference and does not define
an actual child. In such case <code>$new_child</code> is not inserted.
</p>
<p class="POD_TEXT">
See also the <a class="POD_LINK" href="#_yatw_insert_before_">insert_before</a> 
method for <code>Parse::Eyapp:YATW</code> treeregexp transformation objects
</p>
<p></p>
<h3 class="POD_HEAD2"><a name="_node_insert_after_p">$node-&gt;insert_after($position, $new_child)</a></h3>
<p class="POD_TEXT">
Inserts <code>$newchild</code> after <code>$position</code> in the list of children of <code>$node</code>.
Variable <code>$position</code> can be an index or a reference.
</p>
<p class="POD_TEXT">
The method throws an exception if <code>$position</code> is an index and is not
in the range of <code>$node-</code>children&gt;.
</p>
<p class="POD_TEXT">
The method throws a warning if <code>$position</code> is a reference and does not exists
in the list of children. In such case <code>$new_child</code> is not inserted.
</p>
<h3 class="POD_HEAD2"><a name="_node_translation_sc">$node-&gt;translation_scheme</a></h3>
<p class="POD_TEXT">
Traverses $node. Each time a CODE node is visited the subroutine referenced
is called with arguments the node and its children. Usually the code will decorate
the nodes with new attributes or will update existing ones. Obviously this method
does nothing for an ordinary AST. It is used after compiling
an Eyapp program that makes use of the <code>%metatree</code> directive.
</p>
<h3 class="POD_HEAD2"><a name="_node_bud">$node-&gt;bud</a></h3>
<p class="POD_TEXT">
Bottom-up decorator. The tree is traversed bottom-up. The set of
transformations is applied to each node in the order
supplied by the user. As soon as one succeeds
no more transformations are applied.
For an example  see the files <code>examples/Types.eyp</code> 
and <code>examples/Trans.trg</code>.  The code below 
shows an extract of the type-checking phase:
</p>
<pre class="POD_VERBATIM">
  nereida:~/src/perl/YappWithDefaultAction/examples&gt; \
                          sed -ne &#39;600,611p&#39; Types.eyp
   my @typecheck = (
     our $inum,
     our $charconstant,
     our $bin,
     our $arrays,
     our $assign,
     our $control,
     our $functioncall,
     our $statements,
   );

   $t-&gt;bud(@typecheck);

  nereida:~/src/perl/YappWithDefaultAction/examples&gt; \
                          sed -ne &#39;183,192p&#39; Trans.trg
  control: /IF|IFELSE|WHILE/:con($bool)
    =&gt; {
      $bool = char2int($con, 0) if $bool-&gt;{t} == $CHAR;
        type_error(&quot;Condition must have integer type!&quot;, $bool-&gt;line)
      unless $bool-&gt;{t} == $INT;

      $con-&gt;{t} = $VOID;

      return 1;
    }
</pre>
<h2 class="POD_HEAD1"><a name="TRANSFORMATIONS_Pars">TRANSFORMATIONS: Parse::Eyapp:YATW</a></h2>
<p class="POD_TEXT">
Parse::Eyapp:YATW objects represent tree transformations.
</p>
<p></p>
<p></p>
<h3 class="POD_HEAD2"><a name="Parse_Eyapp_Node_new1">Parse::Eyapp::Node-&gt;new</a></h3>
<p class="POD_TEXT">
Builds a treeregexp transformation object.
Though usually you build a transformation by means of Treeregexp programs
you can directly invoke the method to build a tree transformation.
A transformation object can be built from a function 
that conforms to the YATW tree transformation call protocol.
</p>
<p class="POD_TEXT">
Follows an example (file <code>examples/12ts_simplify_with_s.pl</code>):
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; \
        sed -ne &#39;68,$p&#39; 12ts_simplify_with_s.pl | cat -n
  1  sub is_code {
  2    my $self = shift; # tree
  3
  4    # $_[0] is the father, $_[1] the index
  5    if ((ref($self) eq &#39;CODE&#39;)) {
  6      splice(@{$_[0]-&gt;{children}}, $_[1], 1);
  7      return 1;
  8    }
  9    return 0;
 10  }
 11
 12  Parse::Eyapp-&gt;new_grammar(
 13    input=&gt;$translationscheme,
 14    classname=&gt;&#39;Calc&#39;,
 15    firstline =&gt;7,
 16  );
 17  my $parser = Calc-&gt;new();                # Create the parser
 18
 19  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*-3\n&quot;;  print &quot;2*-3\n&quot;; # Set the input
 20  my $t = $parser-&gt;Run;                    # Parse it
 21  print $t-&gt;str.&quot;\n&quot;;
 22  my $p = Parse::Eyapp::YATW-&gt;new(PATTERN =&gt; \&amp;is_code);
 23  $p-&gt;s($t);
 24  { no warnings; # make attr info available only for this display
 25    local *TERMINAL::info = sub { $_[0]{attr} };
 26    print $t-&gt;str.&quot;\n&quot;;
 27  }
</pre>
<p class="POD_TEXT">
After the <code>Parse::Eyapp::YATW</code> object <code>$p</code> is built at line 22
the call to method <code>$p-&gt;s($t)</code> applies  the 
transformation <code>is_code</code> using a bottom-up traversing of the tree <code>$t</code>.
The effect achieved is the elimination of <code>CODE</code> references
in the translation scheme tree.
When executed the former code produces:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; 12ts_simplify_with_s.pl
 2*-3
 EXP(TIMES(NUM(TERMINAL,CODE),TERMINAL,UMINUS(TERMINAL,NUM(TERMINAL,CODE),CODE),CODE),CODE)
 EXP(TIMES(NUM(TERMINAL[2]),TERMINAL[*],UMINUS(TERMINAL[-],NUM(TERMINAL[3]))))
</pre>
<p class="POD_TEXT">
The file <code>foldrule6.pl</code> in the <code>examples/</code> distribution directory
gives you another example:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n foldrule6.pl
   1  #!/usr/bin/perl -w
   2  use strict;
   3  use Rule6;
   4  use Parse::Eyapp::YATW;
   5
   6  my %BinaryOperation = (PLUS=&gt;&#39;+&#39;, MINUS =&gt; &#39;-&#39;, TIMES=&gt;&#39;*&#39;, DIV =&gt; &#39;/&#39;);
   7
   8  sub set_terminfo {
   9    no warnings;
  10    *TERMINAL::info = sub { $_[0]{attr} };
  11  }
  12  sub is_foldable {
  13    my ($op, $left, $right);
  14    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
  15    return 0 unless ($left = $_[0]-&gt;child(0), $left-&gt;isa(&#39;NUM&#39;));
  16    return 0 unless ($right = $_[0]-&gt;child(1), $right-&gt;isa(&#39;NUM&#39;));
  17
  18    my $leftnum = $left-&gt;child(0)-&gt;{attr};
  19    my $rightnum = $right-&gt;child(0)-&gt;{attr};
  20    $left-&gt;child(0)-&gt;{attr} = eval &quot;$leftnum $op $rightnum&quot;;
  21    $_[0] = $left;
  22  }
  23
  24  my $parser = new Rule6();
  25  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*3&quot;;
  26  my $t = $parser-&gt;Run;
  27  &amp;set_terminfo;
  28  print &quot;\n***** Before ******\n&quot;;
  29  print $t-&gt;str;
  30  my $p = Parse::Eyapp::YATW-&gt;new(PATTERN =&gt; \&amp;is_foldable);
  31  $p-&gt;s($t);
  32  print &quot;\n***** After ******\n&quot;;
  33  print $t-&gt;str.&quot;\n&quot;;
</pre>
<p class="POD_TEXT">
when executed produces:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; foldrule6.pl

 ***** Before ******
 TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
 ***** After ******
 NUM(TERMINAL[6])
</pre>
<h3 class="POD_HEAD2"><a name="The_YATW_Tree_Transf">The YATW Tree Transformation Call Protocol</a></h3>
<p class="POD_TEXT">
For a subroutine  <code>pattern_sub</code> to work as a YATW tree transformation
- as sub <code>is_code</code> above - has to conform to the following
call description:
</p>
<pre class="POD_VERBATIM">
  pattern_sub(
      $_[0],  # Node being visited
      $_[1],  # Father of this node
      $index, # Index of this node in @Father-&gt;children
      $self,  # The YATW pattern object
  );
</pre>
<p class="POD_TEXT">
The <code>pattern_sub</code> must return TRUE if matched 
and FALSE otherwise.
</p>
<p class="POD_TEXT">
The protocol may change in the near future. 
Avoid using other information than the fact that 
the first argument 
is the node being visited.
</p>
<p></p>
<h3 class="POD_HEAD2"><a name="Parse_Eyapp_YATW_bui">Parse::Eyapp::YATW-&gt;buildpatterns</a></h3>
<p class="POD_TEXT">
Works as Parse::Eyapp-&gt;new but receives an array of subs 
conforming to the YATW Tree Transformation Call Protocol.
</p>
<pre class="POD_VERBATIM">
  our @all = Parse::Eyapp::YATW-&gt;buildpatt(\&amp;delete_code, \&amp;delete_tokens);
</pre>
<h3 class="POD_HEAD2"><a name="_yatw_delete">$yatw-&gt;delete</a></h3>
<p class="POD_TEXT">
The root of the tree that is currently matched 
by the YATW transformation <code>$yatw</code> will be deleted from 
the tree as soon as is safe. That usually means 
when the processing of their siblings
is finished. The following
example (taken from file <code>examples/13ts_simplify_with_delete.pl</code> in 
the Parse::Eyapp distribution) 
illustrates how to eliminate CODE and syntactic terminals from the 
syntax tree:
</p>
<pre class="POD_VERBATIM">
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \
        sed -ne &#39;62,$p&#39; 13ts_simplify_with_delete.pl | cat -n
  1  sub not_useful {
  2    my $self = shift; # node
  3    my $pat = $_[2];  # get the YATW object
  4
  5    (ref($self) eq &#39;CODE&#39;) or ((ref($self) eq &#39;TERMINAL&#39;) and ($self-&gt;{token} eq $self-&gt;{attr}))
  6      or do { return 0 };
  7    $pat-&gt;delete();
  8    return 1;
  9  }
 10
 11  Parse::Eyapp-&gt;new_grammar(
 12    input=&gt;$translationscheme,
 13    classname=&gt;&#39;Calc&#39;,
 14    firstline =&gt;7,
 15  );
 16  my $parser = Calc-&gt;new();                # Create the parser
 17
 18  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*3\n&quot;; print $parser-&gt;YYData-&gt;{INPUT};
 19  my $t = $parser-&gt;Run;                    # Parse it
 20  print $t-&gt;str.&quot;\n&quot;;                      # Show the tree
 21  my $p = Parse::Eyapp::YATW-&gt;new(PATTERN =&gt; \&amp;not_useful); 
 22  $p-&gt;s($t);                               # Delete nodes
 23  print $t-&gt;str.&quot;\n&quot;;                      # Show the tree
</pre>
<p class="POD_TEXT">
when executed we get the following output:
</p>
<pre class="POD_VERBATIM">
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 13ts_simplify_with_delete.pl
 2*3
 EXP(TIMES(NUM(TERMINAL,CODE),TERMINAL,NUM(TERMINAL,CODE),CODE))
 EXP(TIMES(NUM(TERMINAL),NUM(TERMINAL))
</pre>
<h3 class="POD_HEAD2"><a name="_yatw_unshift_b_">$yatw-&gt;unshift($b)</a></h3>
<p class="POD_TEXT">
Safely unshifts the node <code>$b</code> in the list of children of the father 
of the node that matched
with <code>$yatw</code> (i.e in $_[0]). 
The following example (file <code>examples/26delete_with_trreereg.pl</code>
shows a YATW transformation
<code>insert_child</code> that illustrates the use of <code>unshift</code>:
</p>
<pre class="POD_VERBATIM">
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \
         sed -ne &#39;70,$p&#39; 26delete_with_trreereg.pl | cat -n
  1  my $transform = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
  2
  3      delete_code : CODE =&gt; { $delete_code-&gt;delete() }
  4
  5      {
  6        sub not_semantic {
  7          my $self = shift;
  8          return  1 if ((ref($self) eq &#39;TERMINAL&#39;) and ($self-&gt;{token} eq $self-&gt;{attr}));
  9          return 0;
 10        }
 11      }
 12
 13      delete_tokens : TERMINAL and { not_semantic($TERMINAL) } =&gt; {
 14        $delete_tokens-&gt;delete();
 15      }
 16
 17      insert_child : TIMES(NUM(TERMINAL), NUM(TERMINAL)) =&gt; {
 18        my $b = Parse::Eyapp::Node-&gt;new( &#39;UMINUS(TERMINAL)&#39;,
 19                 sub { $_[1]-&gt;{attr} = &#39;4.5&#39; });
 20
 21        $insert_child-&gt;unshift($b);
 22      }
 23    },
 24  )-&gt;generate();
 25
 26  Parse::Eyapp-&gt;new_grammar(
 27    input=&gt;$translationscheme,
 28    classname=&gt;&#39;Calc&#39;,
 29    firstline =&gt;7,
 30  );
 31  my $parser = Calc-&gt;new();                # Create the parser
 32
 33  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*3\n&quot;; print $parser-&gt;YYData-&gt;{INPUT}; # Set the input
 34  my $t = $parser-&gt;Run;                # Parse it
 35  print $t-&gt;str.&quot;\n&quot;;                        # Show the tree
 36  # Get the AST
 37  our ($delete_tokens, $delete_code);
 38  $t-&gt;s($delete_tokens, $delete_code);
 39  print $t-&gt;str.&quot;\n&quot;;                        # Show the tree
 40  our $insert_child;
 41  $insert_child-&gt;s($t);
 42  print $t-&gt;str.&quot;\n&quot;;                        # Show the tree
</pre>
<p class="POD_TEXT">
When is executed the program produces the following output:
</p>
<pre class="POD_VERBATIM">
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 26delete_with_trreereg.pl
 2*3
 EXP(TIMES(NUM(TERMINAL,CODE),TERMINAL,NUM(TERMINAL,CODE),CODE))
 EXP(TIMES(NUM(TERMINAL),NUM(TERMINAL)))
 EXP(UMINUS(TERMINAL),TIMES(NUM(TERMINAL),NUM(TERMINAL)))
</pre>
<p></p>
<p class="POD_TEXT">
Don&#39;t try to take advantage that the transformation sub receives
in $_[1] a reference to the father (see the section YATW Tree Transformation
protocol) and do something like:
</p>
<pre class="POD_VERBATIM">
  unshift $_[1]-&gt;{children}, $b
</pre>
<p class="POD_TEXT">
it is unsafe.
</p>
<h3 class="POD_HEAD2"><a name="_yatw_insert_before_">$yatw-&gt;insert_before($node)</a></h3>
<p class="POD_TEXT">
Safely inserts $node in the list of children
node before the node $_[0] that matched with <code>$yatw</code>.
</p>
<p class="POD_TEXT">
The following example (file <code>t/33moveinvariantoutofloop.t</code>)
illustrates its use:
</p>
<pre class="POD_VERBATIM">
  my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
    moveinvariant: WHILE(VAR($b), BLOCK(@a, ASSIGN($x, $e), @c)) 
         and { is_invariant($ASSIGN, $WHILE) } =&gt; {
           my $assign = $ASSIGN;
           $BLOCK-&gt;delete($ASSIGN);
           $moveinvariant-&gt;insert_before($assign);
         }
    },
  );
</pre>
<p class="POD_TEXT">
Here the <code>$assign</code> tree will be moved before the node 
<code>$WHILE</code> in the list of siblings of <code>$WHILE</code>
(presumably the father is a <code>BLOCK</code> node).
</p>
<h2 class="POD_HEAD1"><a name="Matching_Trees">Matching Trees</a></h2>
<p class="POD_TEXT">
Both the transformation objects in <code>Parse::Eyapp::YATW</code>
and the nodes in <code>Parse::Eyapp::Node</code> have a method 
named <code>m</code> for matching.
</p>
<p class="POD_TEXT">
For a <code>Parse::Eyapp::YATW</code> object, the method -when called
in a list context- returns a list of 
<code>Parse::Eyapp::Node::Match</code> nodes referencing
the nodes of the actual tree that have matched.
The nodes in the list are organized in a hierarchy.
</p>
<p class="POD_TEXT">
The nodes are sorted in the list of trees (a forest)
according to a depth-first visit of the actual tree <code>$t</code>.
</p>
<p class="POD_TEXT">
In a scalar context <code>m</code> returns the first element of
the list.
</p>
<p class="POD_TEXT">
Let us denote by <code>$t</code> the actual tree being searched
and <code>$r</code> one of the <code>Parse::Eyapp::Node::Match</code>
nodes in the resulting forest.
Then we have the following methods:
</p>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="The_method_r_node_re"><p>The method <code>$r-&gt;node</code> return the node <code>$t</code> of the actual 
tree that matched</p></a>
<li class="POD_ITEM"><a name="The_method_r_father_"><p>The method <code>$r-&gt;father</code> returns the tree in the matching forest.
The father is defined by this property:
<code>$r-&gt;father-&gt;node</code> is the nearest ancestor of
<code>$r-&gt;node</code> that matched with the treeregexp pattern.
That is, there is no ancestor that matched between
<code>$r-&gt;node</code> and <code>$r-&gt;father-&gt;node</code>.
Otherwise <code>$r-&gt;father</code> is <code>undef</code></p></a>
<li class="POD_ITEM"><a name="_"></a>
<p class="POD_TEXT">
The method <code>$r-&gt;coord</code> returns the coordinates of the actual tree
that matched using s.t similar to the Dewey notation.
for example, the coordinate <code>&quot;.1.3.2&quot;</code> 
denotes the node <code>$t-&gt;child(1)-&gt;child(3)-&gt;child(2)</code>, where <code>$t</code>
is the root of the search.
</p>
<li class="POD_ITEM"><a name="_1"></a>
<p class="POD_TEXT">
The method <code>$r-&gt;depth</code> returns the depth of <code>$r-&gt;node</code> 
in <code>$t</code>.
</p>
<li class="POD_ITEM"><a name="_2"></a>
<p class="POD_TEXT">
When called as a <code>Parse::Eyapp::Node</code> method, <code>$r-&gt;names</code>
returns the array of names of the transformations that matched.
</p>
</ul>
<p class="POD_TEXT">
The following example illustrates a use of <code>m</code> as 
a <code>Parse::Eyapp:YATW</code> method.
It solves a problem of scope analysis in a C compiler:
matching each <code>RETURN</code> statement with the function
that surrounds it. The treeregexp used is:
</p>
<pre class="POD_VERBATIM">
  retscope: /FUNCTION|RETURN/
</pre>
<p class="POD_TEXT">
and the code that solves the problem is:
</p>
<pre class="POD_VERBATIM">
 # Scope Analysis: Return-Function
 my @returns = $retscope-&gt;m($t); 
 for (@returns) {
   my $node = $_-&gt;node;
   if (ref($node) eq &#39;RETURN&#39;) {
     my $function = $_-&gt;father-&gt;node;
     $node-&gt;{function}  = $function;
     $node-&gt;{t} = $function-&gt;{t};
   }
 }
</pre>
<p class="POD_TEXT">
The first line gets a list of <code>Parse::Eyapp::Node::Match</code> nodes 
describing  the actual nodes that matched <code>/FUNCTION|RETURN/</code>. 
If the node described by <code>$_</code> is a <code>&#39;RETURN&#39;</code> node,
the expresion <code> $_-&gt;father-&gt;node</code> must necessarily point
to the function node that surrounds it.
</p>
<p class="POD_TEXT">
The second example shows the use of <code>m</code> as
a <code>Parse::Eyapp::Node</code> method.
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n m2.pl
  1  #!/usr/bin/perl -w
  2  use strict;
  3  use Rule6;
  4  use Parse::Eyapp::Treeregexp;
  5
  6  Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
  7    fold: /times|plus|div|minus/i:bin(NUM($n), NUM($m))
  8    zero_times_whatever: TIMES(NUM($x), .) and { $x-&gt;{attr} == 0 }
  9    whatever_times_zero: TIMES(., NUM($x)) and { $x-&gt;{attr} == 0 }
 10  })-&gt;generate();
 11
 12  # Syntax analysis
 13  my $parser = new Rule6();
 14  print &quot;Expression: &quot;; $parser-&gt;YYData-&gt;{INPUT} = &lt;&gt;;
 15  my $t = $parser-&gt;Run;
 16  local $Parse::Eyapp::Node::INDENT = 1;
 17  print &quot;Tree:&quot;,$t-&gt;str,&quot;\n&quot;;
 18
 19  # Search
 20  my $m = $t-&gt;m(our ($fold, $zero_times_whatever, $whatever_times_zero));
 21  print &quot;Match Node:&quot;,$m-&gt;str,&quot;\n&quot;;
</pre>
<p class="POD_TEXT">
When executed with input <code>0*0*0</code> the program generates this output:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; m2.pl
 Expression: 0*0*0
 Tree:
 TIMES(
   TIMES(
     NUM(
       TERMINAL
     ),
     NUM(
       TERMINAL
     )
   ),
   NUM(
     TERMINAL
   )
 )
 Match Node:
 Match[TIMES:0:whatever_times_zero](
   Match[TIMES:1:fold,zero_times_whatever,whatever_times_zero]
 )
</pre>
<p class="POD_TEXT">
The representation of <code>Match</code> nodes by <code>str</code> deserves a comment.
<code>Match</code> nodes have their own <code>info</code> method. It returns a string
containing the concatenation of the class of <code>$r-&gt;node</code> 
(i.e. the actual node that matched), the depth
(<code>$r-&gt;depth</code>) and the names of the transformations
that matched (as provided by the method <code>$r-&gt;names</code>)
</p>
<h3 class="POD_HEAD2"><a name="The_SEVERITY_option_">The <code>SEVERITY</code> option of <code>Parse::Eyapp::Treeregexp::new</code></a></h3>
<p class="POD_TEXT">
The <code>SEVERITY</code> option of <code>Parse::Eyapp::Treeregexp::new</code> controls the
way matching succeeds regarding the number of children.
To illustrate its use let us consider the following example.
The grammar <code>Rule6</code> used by the example is similar
to the one in the Synopsis example.
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n numchildren.pl
  1  #!/usr/bin/perl -w
  2  use strict;
  3  use Rule6;
  4  use Parse::Eyapp::Treeregexp;
  5  use Parse::Eyapp::Node;
  6
  7  sub TERMINAL::info { $_[0]{attr} }
  8
  9  my $severity = shift || 0;
 10  my $parser = new Rule6();
 11  $parser-&gt;YYData-&gt;{INPUT} = shift || &#39;0*2&#39;;
 12  my $t = $parser-&gt;Run;
 13
 14  my $transform = Parse::Eyapp::Treeregexp-&gt;new(
 15    STRING =&gt; q{
 16      zero_times_whatever: TIMES(NUM($x)) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
 17    },
 18    SEVERITY =&gt; $severity,
 19    FIRSTLINE =&gt; 15,
 20  )-&gt;generate;
 21
 22  $t-&gt;s(our @all);
 23
 24  print $t-&gt;str,&quot;\n&quot;;
</pre>
<p></p>
<p class="POD_TEXT">
The program gets the severity level from the command line (line 9).
The specification of the term <code>TIMES(NUM($x))</code> inside the
transformation <code>zero_times_whatever</code> does not
clearly state that <code>TIMES</code> must have two children.
There are several interpretations of the treregexp depending
on the level fixed for <code>SEVERITY</code>:
</p>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="0_TIMES_must_have_at"><p>0: <code>TIMES</code> must have at least one child. Don&#39;t care if it has more.</p></a>
<li class="POD_ITEM"><a name="1_TIMES_must_have_ex"><p>1: <code>TIMES</code> must have exactly one child.</p></a>
<li class="POD_ITEM"><a name="2_TIMES_must_have_ex"><p>2: <code>TIMES</code> must have exactly one child. When visit a 
<code>TIMES</code> node with a different number of children issue a warning.</p></a>
<li class="POD_ITEM"><a name="3_TIMES_must_have_ex"><p>3: <code>TIMES</code> must have exactly one child.  When visit a
<code>TIMES</code> node with a different number of children issue an
error.</p></a>
</ul>
<p class="POD_TEXT">
Observe the change in behavior according to the level of <code>SEVERITY</code>:
</p>
<pre class="POD_VERBATIM">
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; numchildren.pl 0 &#39;0*2&#39;
 NUM(TERMINAL[0])
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; numchildren.pl 1 &#39;0*2&#39;
 TIMES(NUM(TERMINAL[0]),NUM(TERMINAL[2]))
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; numchildren.pl 2 &#39;0*2&#39;
 Warning! found node TIMES with 2 children.
 Expected 1 children (see line 16 of numchildren.pl)&quot;
 TIMES(NUM(TERMINAL[0]),NUM(TERMINAL[2]))
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; numchildren.pl 3 &#39;0*2&#39;
 Error! found node TIMES with 2 children.
 Expected 1 children (see line 16 of numchildren.pl)&quot;
  at (eval 2) line 29
</pre>
<p></p>
<h2 class="POD_HEAD1"><a name="Tree_Substitution_Th">Tree Substitution: The <code>s</code> methods</a></h2>
<p class="POD_TEXT">
Both <code>Parse::Eyapp:Node</code> and <code>Parse::Eyapp::YATW</code> objects (i.e.
nodes and tree transformations) are provided with a <code>s</code> method.
</p>
<p class="POD_TEXT">
In the case of a <code>Parse::Eyapp::YATW</code> object the method <code>s</code>
applies the tree transformation using a single bottom-up traversing:
the transformation is applied to the children subtrees and -if the current node
matches - to the current nodes.
</p>
<p class="POD_TEXT">
For <code>Parse::Eyapp:Node</code> nodes the set of transformations is applied
to each node until no transformation matches any more.
The example in the <a class="POD_LINK" href="#SYNOPSIS">SYNOPSIS</a> section illustrates the use:
</p>
<pre class="POD_VERBATIM">
  1  # Let us transform the tree. Define the tree-regular expressions ..
  2  my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
  3    { #  Example of support code
  4      my %Op = (PLUS=&gt;&#39;+&#39;, MINUS =&gt; &#39;-&#39;, TIMES=&gt;&#39;*&#39;, DIV =&gt; &#39;/&#39;);
  5    }
  6    constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($x), NUM($y))
  7      =&gt; {
  8        my $op = $Op{ref($_[0])};
  9        $x-&gt;{attr} = eval  &quot;$x-&gt;{attr} $op $y-&gt;{attr}&quot;;
 10        $_[0] = $NUM[0];
 11      }
 12    uminus: UMINUS(NUM($x)) =&gt; { $x-&gt;{attr} = -$x-&gt;{attr}; $_[0] = $NUM }
 13    zero_times_whatever: TIMES(NUM($x), .) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
 14    whatever_times_zero: TIMES(., NUM($x)) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
 15    },
 16    OUTPUTFILE=&gt; &#39;main.pm&#39;
 17  );
 18  $p-&gt;generate(); # Create the tranformations
 19 
 20  $t-&gt;s($uminus); # Transform UMINUS nodes
 21  $t-&gt;s(@all);    # constant folding and mult. by zero
</pre>
<p class="POD_TEXT">
The call at line 20 can be substituted by <code>$uminus-&gt;s($t)</code>
without changes.
</p>
<h2 class="POD_HEAD1"><a name="Parse_Eyapp_Scope">Parse::Eyapp::Scope</a></h2>
<p class="POD_TEXT">
A scope manager helps to compute the mapping function
that maps the uses (instances) of 
objects to its definitions. For instance, to asociate
each ocurrence of an identifier with the declaration
that applies to it. Another example is to associate each occurrence
of a <code>CONTINUE</code> or <code>BREAK</code> node with the 
shallowest <code>LOOP</code> that encloses it. Or to associate a <code>GOTO</code>
node to jump to, that is,
with the statement node associated with the label.
</p>
<p class="POD_TEXT">
The compiler writer must mark at the appropriate time 
(new block for identifier scope analysis,
new loop for loop scope analysis, etc.) the <i>beginning of a new scope</i>
calling the method <a class="POD_LINK" href="#_scope_begin_scope">begin_scope</a>.
From that point on any <i>ocurring instance</i> of an object 
(for example,
variables in expressiones for identifier scope analysis, breaks and continues
for loop scope analysis, etc.) must be declared 
calling the method <a class="POD_LINK" href="#_scope_scope_instanc">scope_instance</a>.
The programmer must also mark the <i>end of the current scope</i> 
at the appropriate time.
</p>
<h3 class="POD_HEAD2"><a name="_scope_end_scope">$scope-&gt;end_scope</a></h3>
<p class="POD_TEXT">
There are two ways of calling <code>$scope-&gt;end_scope</code>.
The first one is for Scope Analysis Problems where
a symbol table is needed (for example in variable scope analysis).
</p>
<h4 class="POD_HEAD3"><a name="_scope_end_scope_wit">$scope-&gt;end_scope with first Arg a Symbol Table</a></h4>
<p class="POD_TEXT">
For each <i>ocurring instance</i> of an object <code>$x</code>
that occurred since the last call to  <a class="POD_LINK" href="#_scope_begin_scope">begin_scope</a>
the call to
</p>
<pre class="POD_VERBATIM">
  $scope-&gt;end_scope(\%symboltable, $definition_node, &#39;attr1&#39;, &#39;attr2&#39;, ... )
</pre>
<p class="POD_TEXT">
decorates the <i>ocurring instance</i> <code>$x</code> with several attributes:
</p>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="An_entry_x_SCOPE_NAM"><p>An entry <code>$x-&gt;{SCOPE_NAME}</code> is built that will reference <code>$definition_node</code>.</p></a>
<li class="POD_ITEM"><a name="An_entry_x_ENTRY_NAM"><p>An entry <code>$x-&gt;{ENTRY_NAME}</code> is built. That
entry references <code>$symboltable{$x-&gt;key}</code> (to have a
faster access from the instance to the attributes of the object).</p></a>
<li class="POD_ITEM"><a name="For_each_aditional_a"><p>For each aditional arguments <code>attr#k</code> an
entry <code>$x-&gt;{attr#k</code>} will be built.
That entry references <code>$symboltable{$x-&gt;key}{attr#k}</code>. Therefore
the entry for <code>$x</code> in the symbol table must already 
have a field named <code>attr#k</code>.</p></a>
</ul>
<p class="POD_TEXT">
In a list context <code>$scope&gt;end_scope</code> returns
two references. The first one
is a reference to a list of node instances
that weren&#39;t defined in the current scope.
The second is a reference to a list of nodes
that were defined in this scope. 
In a scalar context returns the first of these two.
An instance <code>$x</code> is <i>defined</i> if, and only if, 
<code>exists $symboltable{$_-&gt;key}</code>.
</p>
<h4 class="POD_HEAD3"><a name="_scope_end_scope_for">$scope-&gt;end_scope for Simple Scope Analysis</a></h4>
<p class="POD_TEXT">
Some scope analysis problems do not require the existence
of a symbol table (for instance, the problem of associating
a <code>RETURN</code> node with the <code>FUNCTION</code> that encloses it). 
For such kind of problems <code>$scope&gt;end_scope</code> provides
a second form of call.
The second way to call <code>$scope&gt;end_scope</code> is
</p>
<pre class="POD_VERBATIM">
                 $declared = $scopemanager-&gt;end_scope($definition_node);
</pre>
<p class="POD_TEXT">
The only argument is the reference to the node that controls/defines
the scope. The method returns a reference to the declared
nodes. Any node instanced with <code>scope_instance</code>
since the last call to <code>begin_scope</code> is considered <i>declared</i>.
</p>
<h3 class="POD_HEAD2"><a name="_scope_begin_scope">$scope-&gt;begin_scope</a></h3>
<p class="POD_TEXT">
Marks the beginning of an scope.
Example (file <code>examples/Types.eyp</code>):
</p>
<pre class="POD_VERBATIM">
                  loopPrefix:
                      $WHILE &#39;(&#39; expression &#39;)&#39;
                        {
                          $loops-&gt;begin_scope;
                          $_[3]-&gt;{line} = $WHILE-&gt;[1];
                          $_[3]
                        }
</pre>
<h3 class="POD_HEAD2"><a name="_scope_scope_instanc">$scope-&gt;scope_instance</a></h3>
<p class="POD_TEXT">
Declares the node argument to be an occurring instance of the scope:
</p>
<pre class="POD_VERBATIM">
   nereida:~/doc/casiano/PLBOOK/PLBOOK/code&gt; \
       sed -ne &#39;375,380p&#39; Simple6.eyp | cat -n
    1      $Variable &#39;=&#39; binary
    2        {
    3          my $parser = shift;
    4          $ids-&gt;scope_instance($Variable);
    5          $parser-&gt;YYBuildAST(@_);
    6        }
</pre>
<p></p>
<h3 class="POD_HEAD2"><a name="Parse_Eyapp_Scope_ne">Parse::Eyapp::Scope-&gt;new</a></h3>
<p class="POD_TEXT">
<code>Parse::Eyapp::Scope-&gt;new</code> returns a scope managment object. 
The scope mapping function is implemented 
by <code>Parse::Eyapp::Scope</code> through a set of attributes
that are added to the nodes involved in the scope analysis.
Some of these attributes can be specified 
using the parameters of <code>Parse::Eyapp::Scope-&gt;new</code>.
The arguments of <code>new</code> are:
</p>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="SCOPE_NAME"><p><code>SCOPE_NAME</code> 
is the name choosed for the attribute of the 
<i>node instance</i>  which will held
the reference to the <i>definition node</i>.
If is not specified it will take the value <code>&quot;scope&quot;</code>.</p></a>
<li class="POD_ITEM"><a name="ENTRY_NAME_is_the_na"><p><code>ENTRY_NAME</code> is the name of the attribute of the
<i>node instance</i>  which will held
the reference to the symbol table entry.
By default takes the value <code>&quot;entry&quot;</code>.</p></a>
<li class="POD_ITEM"><a name="SCOPE_DEPTH_is_the_n"><p><code>SCOPE_DEPTH</code> is the name for an attribute of the es el nombre del atributo del nodo &aacute;mbito (nodo bloque) y contiene la profundidad de anidamiento del &aacute;mbito. Es opcional. Si no se especifica no ser&aacute; guardado.</p></a>
</ul>
<p></p>
<h2 class="POD_HEAD1"><a name="ENVIRONMENT">ENVIRONMENT</a></h2>
<p class="POD_TEXT">
Remember to set the environment variable <code>PERL5LIB</code>
if you decide to install <code>Parse::Eyapp</code> at a location other than the standard.
For example, on a bash or sh:
</p>
<pre class="POD_VERBATIM">
  export PERL5LIB-/home/user/wherever_it_is/lib/:$PERL5LIB
</pre>
<p class="POD_TEXT">
on a <code>csh</code> or &lt;tcsh&gt;
</p>
<pre class="POD_VERBATIM">
  setenv PERL5LIB /home/user/wherever_it_is/lib/:$PERL5LIB
</pre>
<p class="POD_TEXT">
Be sure the scripts <code>eyapp</code> and <code>treereg</code> are in the execution PATH.
</p>
<h2 class="POD_HEAD1"><a name="DEPENDENCIES">DEPENDENCIES</a></h2>
<p class="POD_TEXT">
This distribution depends on the following modules:
</p>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="List_MoreUtils"><p><u>List::MoreUtils</u></p></a>
<li class="POD_ITEM"><a name="List_Util"><p><u>List::Util</u></p></a>
<li class="POD_ITEM"><a name="Data_Dumper"><p><u>Data::Dumper</u></p></a>
<li class="POD_ITEM"><a name="Pod_Usage"><p><u>Pod::Usage</u></p></a>
</ul>
<p class="POD_TEXT">
It seems that <u>List::Util</u> is in the core of Perl
distributions since version 5.73:
</p>
<pre class="POD_VERBATIM">
  &gt; perl -MModule::CoreList -e &#39;print Module::CoreList-&gt;first_release(&quot;List::Util&quot;)&#39;
  5.007003
</pre>
<p class="POD_TEXT">
and <u>Data::Dumper</u> is also in the core since 5.5:
</p>
<pre class="POD_VERBATIM">
  &gt; perl -MModule::CoreList -e &#39;print Module::CoreList-&gt;first_release(&quot;Data::Dumper&quot;)&#39;
  5.005
</pre>
<p class="POD_TEXT">
and <u>Pod::Usage</u> is also in the core since 5.6:
</p>
<pre class="POD_VERBATIM">
  &gt; perl -MModule::CoreList -e &#39;print Module::CoreList-&gt;first_release(&quot;Pod::Usage&quot;)&#39;
  5.006
</pre>
<p class="POD_TEXT">
I also recommend the following modules:
</p>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="Test_Pod"><p><u>Test::Pod</u></p></a>
<li class="POD_ITEM"><a name="Test_Warn"><p><u>Test::Warn</u></p></a>
<li class="POD_ITEM"><a name="Test_Exception"><p><u>Test::Exception</u></p></a>
</ul>
<p class="POD_TEXT">
The dependence on  <u>Test::Warn</u>, <u>Test::Pod</u> and <u>Test::Exception</u> is merely for
the execution of tests. If the modules aren&#39;t installed the tests
depending on them will be skipped.
</p>
<h2 class="POD_HEAD1"><a name="INSTALLATION">INSTALLATION</a></h2>
<p class="POD_TEXT">
To install it, follow the traditional mantra:
</p>
<pre class="POD_VERBATIM">
                                 perl Makefile.PL
                                 make
                                 make test
                                 make install
</pre>
<p class="POD_TEXT">
Also:
</p>
<p></p>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="Make_a_local_copy_of"><p>Make a local copy of the <code>examples/</code> directory in this distribution</p></a>
<li class="POD_ITEM"><a name="Probably_it_will_be_"><p>Probably it will be also a good idea to make a copy of the tests in the <code>t/</code> directory.<br>&nbsp;&nbsp;They also illustrate the use of Eyapp</p></a>
<li class="POD_ITEM"><a name="Print_eyapptut_pdf_a"><p>Print <code>eyapptut.pdf</code> and <code>Eyapp.pdf</code>.</p></a>
<li class="POD_ITEM"><a name="Consider_also_saving"><p>Consider also saving the HTML files</p></a>
<li class="POD_ITEM"><a name="Read_eyapptut_pdf_fi"><p>Read eyapptut.pdf first</p></a>
</ul>
<h2 class="POD_HEAD1"><a name="BUGS_AND_LIMITATIONS">BUGS AND LIMITATIONS</a></h2>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="This_distribution_is"><p>This distribution is an alpha version. 
I plan to make a release in CPAN by February 2007.
Hopefully, at that time the interface will freeze or -at least-
changes in the API will be minor. In the meanwhile 
it will be likely to change.</p></a>
<li class="POD_ITEM"><a name="The_way_Parse_Eyapp_"><p>The way Parse::Eyapp parses Perl code is verbatim the way it does Parse::Yapp 1.05.
I quote Francois Desarmenien <u>Parse::Yapp</u> documentation:</p></a>
<p class="POD_TEXT">
&quot;Be aware that matching braces in Perl is much more difficult than
in C: inside strings they don&#39;t need to match. While in C it is
very easy to detect the beginning of a string construct, or a
single character, it is much more difficult in Perl, as there
are so many ways of writing such literals. So there is no check
for that today. If you need a brace in a double-quoted string, just
quote it (<code>\{</code> or <code>\}</code>). For single-quoted strings, you will need
to make a comment matching it <i>in th right order</i>.
Sorry for the inconvenience.
</p>
<pre class="POD_VERBATIM">
    {
        &quot;{ My string block }&quot;.
        &quot;\{ My other string block \}&quot;.
        qq/ My unmatched brace \} /.
        # Force the match: {
        q/ for my closing brace } /
        q/ My opening brace { /
        # must be closed: }
    }
</pre>
<p class="POD_TEXT">
All of these constructs should work.&quot;
</p>
<p class="POD_TEXT">
I wrote an alternative <i>exact solution</i> but resulted in much slower
code. Therefore, until something better is found, I rather prefer for
Parse::Eyapp to live with this limitation.
</p>
<p class="POD_TEXT">
The same limitation may appear inside header code (code between <code>%{</code> and <code>%}</code>)
</p>
<li class="POD_ITEM"><a name="_3"></a>
<p class="POD_TEXT">
English is not 
my native language. I know for sure this text has
lexical, syntactic and semantic errors. 
I&#39;ll be most gratefull to know about 
any typos, grammar mistakes, 
ways to rewrite paragraphs and misconceptions
you have found.
</p>
<li class="POD_ITEM"><a name="_4"></a>
<p class="POD_TEXT">
I am sure there are unknown bugs. 
Please report problems to Casiano Rodriguez-Leon (casiano@cpan.org).
</p>
</ul>
<h2 class="POD_HEAD1"><a name="SEE_ALSO">SEE ALSO</a></h2>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="Parse_eyapptut"><p><u>Parse::eyapptut</u></p></a>
<li class="POD_ITEM"><a name="The_Eyapp_pdf_and_ey"><p>The <code>Eyapp.pdf</code> and  <code>eyapptut.pdf</code> files accompanying this distribution</p></a>
<li class="POD_ITEM"><a name="perldoc_eyapp_"><p>perldoc <a class="POD_LINK" href="eyapp.html">eyapp</a>,</p></a>
<li class="POD_ITEM"><a name="perldoc_treereg_"><p>perldoc <a class="POD_LINK" href="treereg.html">treereg</a>,</p></a>
<li class="POD_ITEM"><a name="An_lisis_L_xico_y_Si"><p><i>An&aacute;lisis L&eacute;xico y Sint&aacute;ctico</i>, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <a class="POD_LINK" href="http://nereida.deioc.ull.es/~pl/perlexamples/">http://nereida.deioc.ull.es/~pl/perlexamples/</a>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.</p></a>
<p></p>
<li class="POD_ITEM"><a name="Parse_Yapp_"><p><u>Parse::Yapp</u>,</p></a>
<li class="POD_ITEM"><a name="Man_pages_of_yacc_1_"><p>Man pages of yacc(1),</p></a>
<li class="POD_ITEM"><a name="Man_pages_of_bison_1"><p>Man pages of bison(1),</p></a>
<li class="POD_ITEM"><a name="Language_AttributeGr"><p><u>Language::AttributeGrammar</u></p></a>
<li class="POD_ITEM"><a name="Parse_RecDescent_"><p><u>Parse::RecDescent</u>.</p></a>
</ul>
<h2 class="POD_HEAD1"><a name="REFERENCES">REFERENCES</a></h2>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="The_classic_book_Com"><p>The classic book &quot;Compilers: Principles, Techniques, and Tools&quot; by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)</p></a>
</ul>
<h2 class="POD_HEAD1"><a name="AUTHOR">AUTHOR</a></h2>
<p class="POD_TEXT">
Casiano Rodriguez-Leon (casiano@ull.es)
</p>
<p class="POD_TEXT">
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
</p>
<h2 class="POD_HEAD1"><a name="ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h2>
<p class="POD_TEXT">
This work has been supported by CEE (FEDER) and the Spanish Ministry of
<i>Educaci&oacute;n y Ciencia</i> through Plan Nacional I+D+I number TIN2005-08818-C04-04
(ULL::OPLINK project <a class="POD_LINK" href="http://www.oplink.ull.es/">http://www.oplink.ull.es/</a>). 
Support from Gobierno de Canarias was through GC02210601
(Grupos Consolidados).
The University of La Laguna has also supported my work in many ways
and for many years.
</p>
<p class="POD_TEXT">
I wish to thank Francois Desarmenien for his <code>Parse::Yapp</code> module, 
to my students at La Laguna and to the Perl Community. Special thanks to 
my family and Larry Wall.
</p>
<h2 class="POD_HEAD1"><a name="LICENCE_AND_COPYRIGH">LICENCE AND COPYRIGHT</a></h2>
<p class="POD_TEXT">
Copyright (c) 2006 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
</p>
<p class="POD_TEXT">
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998-2001
</p>
<p class="POD_TEXT">
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See <u>perlartistic</u>.
</p>
<p class="POD_TEXT">
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</p>
<hr>
<a class="POD_NAVLINK" href="#Pod_TOP_OF_PAGE">[Top]</a>
</body>
</html>

